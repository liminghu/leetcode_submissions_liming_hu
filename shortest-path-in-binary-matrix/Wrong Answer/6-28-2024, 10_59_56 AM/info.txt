{"id":1303220339,"question_id":1171,"lang":"cpp","lang_name":"C++","time":"7 months, 1 week","timestamp":1719597596,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1303220339/","is_pending":"Not Pending","title":"Shortest Path in Binary Matrix","memory":"N/A","code":"/*\nGiven an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.\nA clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\nAll the visited cells of the path are 0.\nAll the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\nThe length of a clear path is the number of visited cells of this path.\n*/\nclass Solution {\npublic:\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {  //bfs\n        int sz = grid.size(); \n        vector<vector<int>> directions = {{-1, -1}, {-1, 0}, {0, -1}, {-1, 1}, {1, -1}, {0, 1}, {1, 0}, {1, 1} };\n        vector<vector<bool>> visited(sz, vector<bool>(sz, false));\n        int path_len = 0;\n        stack< pair<int, int> > q;\n        pair<int, int> start = { 0,0 };\n\n        if( grid[start.first][start.second] != 0 ) \n            return -1;\n\n        q.push(start);\n        //visited[start.first][start.second] = true;\n        \n        while(!q.empty()) {\n            pair<int, int> current = q.top();\n            q.pop();\n            visited[current.first][current.second] = true;\n            path_len++;\n\n            if(current.first == grid.size()-1 && current.second == grid[0].size()-1) {\n                if( grid[current.first][current.second] != 0 ) \n                    return -1; \n                else\n                    return path_len;\n            };\n                \n            for( int i=0; i < directions.size(); i++ ) {\n                if (current.first+directions[i][0] >= 0 && current.first+directions[i][0] < grid.size() && current.second+directions[i][1] >= 0 && current.second+directions[i][1] < grid.size()) {\n                    if( !visited[ current.first + directions[i][0] ][ current.second + directions[i][1] ]  && grid [ current.first + directions[i][0] ][ current.second + directions[i][1] ] == 0 ) {\n                        q.push( make_pair( current.first+directions[i][0], current.second+directions[i][1] ) );\n                    }\n                }\n            } //for directions\n        } //while queue\n\n        return -1;\n    }\n};","compare_result":"111111111111111111111111111111111110111111110110011111000000110101111100100000000000000011","title_slug":"shortest-path-in-binary-matrix","has_notes":false,"flag_type":1}