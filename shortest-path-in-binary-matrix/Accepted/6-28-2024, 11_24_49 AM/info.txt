{"id":1303243352,"question_id":1171,"lang":"cpp","lang_name":"C++","time":"7 months, 1 week","timestamp":1719599089,"status":10,"status_display":"Accepted","runtime":"40 ms","url":"/submissions/detail/1303243352/","is_pending":"Not Pending","title":"Shortest Path in Binary Matrix","memory":"22.5 MB","code":"/*\nGiven an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.\nA clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\nAll the visited cells of the path are 0.\nAll the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\nThe length of a clear path is the number of visited cells of this path.\n*/\nclass Solution {\npublic:\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {  //bfs\n        int sz = grid.size(); \n        vector<vector<int>> directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1} };\n        //vector<vector<bool>> visited(sz, vector<bool>(sz, false));\n        //int path_len = 0;\n        queue< pair<int, int> > q;\n        pair<int, int> start = { 0, 0 };\n\n        if( grid[start.first][start.second] != 0 ) \n            return -1;\n\n        q.push(start);\n        grid[start.first][start.second] = 1;\n        \n        while(!q.empty()) {\n            pair<int, int> current = q.front();\n            q.pop();\n            int distance = grid[current.first][current.second];\n\n            if(current.first == grid.size()-1 && current.second == grid[0].size()-1) {\n                    return distance; \n            };\n                \n            for( int i=0; i < directions.size(); i++ ) {\n                if (current.first+directions[i][0] >= 0 && current.first+directions[i][0] < grid.size() && current.second+directions[i][1] >= 0 && current.second+directions[i][1] < grid.size()) {\n                    if( grid [ current.first + directions[i][0] ][ current.second + directions[i][1] ] == 0 ) {\n                        q.push( make_pair( current.first+directions[i][0], current.second+directions[i][1] ) );\n                        grid[ current.first + directions[i][0] ][ current.second + directions[i][1] ] = distance +1;\n                    }\n                }\n            } //for directions\n        } //while queue\n\n        return -1;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-in-binary-matrix","has_notes":false,"flag_type":1}