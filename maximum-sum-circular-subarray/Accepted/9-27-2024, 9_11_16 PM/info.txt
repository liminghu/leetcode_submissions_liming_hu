{"id":1404516155,"question_id":954,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1727496676,"status":10,"status_display":"Accepted","runtime":"44 ms","url":"/submissions/detail/1404516155/","is_pending":"Not Pending","title":"Maximum Sum Circular Subarray","memory":"45.6 MB","code":"/*\nGiven a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of \nnums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], \nnums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.\n*/\nclass Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        //the next element of nums[i] is nums[(i + 1) % n] and \n        //the previous element of nums[i] is nums[(i - 1 + n) % n]\n        int n = nums.size();\n        vector<int> dp_pos(n, 0); //dp[i]: the max subarray ending with i.\n        dp_pos[0] = nums[0];\n        for(int i=1; i<n; i++)\n            dp_pos[i] = max(nums[i], nums[i] + dp_pos[i-1]);\n\n        vector<int> dp_neg(n, 0); //dp[i]: the max subarray ending with i.\n        dp_neg[0] = -nums[0];\n        for(int i=1; i<n; i++)\n            dp_neg[i] = max(-nums[i], -nums[i] + dp_neg[i-1]);\n        \n        int max_p = *max_element(dp_pos.begin(), dp_pos.end());\n        int max_n = *max_element(dp_neg.begin(), dp_neg.end());\n        if(max_p < 0)\n            return max_p;\n        int sum = 0;\n        for(int i=0; i<n; i++)\n            sum += nums[i];\n        return max(max_p, sum+max_n);\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-sum-circular-subarray","has_notes":false,"flag_type":1}