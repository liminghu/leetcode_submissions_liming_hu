{"id":1513236173,"question_id":3674,"lang":"cpp","lang_name":"C++","time":"2 weeks, 5 days","timestamp":1737264854,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1513236173/","is_pending":"Not Pending","title":"Count Non-Decreasing Subarrays After K Operations","memory":"N/A","code":"class Solution {\npublic:\n    long long countNonDecreasingSubarrays(vector<int>& nums, int k) {\n        reverse(nums.begin(), nums.end());\n        long long res = 0;\n        deque<int> q;\n        for (int j = 0, i = 0; j < nums.size(); ++j) {\n            while (!q.empty() && nums[q.back()] < nums[j]) {\n                int r = q.back();\n                q.pop_back();\n                int l = q.empty() ? i - 1 : q.back();\n                k -= 1L * (r - l) * (nums[j] - nums[r]);\n            }\n            q.push_back(j);\n            while (k < 0) {\n                k += nums[q.front()] - nums[i];\n                if (q.front() == i) {\n                    q.pop_front();\n                }\n                ++i;\n            }\n            res += j - i + 1;\n        }\n        return res;\n    }\n};","compare_result":"11111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110100110100000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111","title_slug":"count-non-decreasing-subarrays-after-k-operations","has_notes":false,"flag_type":1}