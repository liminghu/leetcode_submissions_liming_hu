{"id":1453887071,"question_id":1142,"lang":"cpp","lang_name":"C++","time":"2 months, 3 weeks","timestamp":1731712986,"status":10,"status_display":"Accepted","runtime":"1907 ms","url":"/submissions/detail/1453887071/","is_pending":"Not Pending","title":"Minimum Knight Moves","memory":"105.8 MB","code":"class Solution {\n    vector<pair<int, int>> dirs = { {1,2}, {1, -2}, {2, 1}, {2, -1}, {-1, 2}, {-1, -2}, {-2, 1}, {-2, -1}};\npublic:\n    int minKnightMoves(int x, int y) {\n        //Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\n        x = abs(x);\n        y = abs(y);\n        queue<pair<int,int>> q;\n        q.push({0, 0});\n        unordered_set<string> visited;\n        int res = 0;\n        while(!q.empty()) {    //BFS\n            int sz = q.size();\n            for(int i=0; i<sz; i++) {\n                pair<int, int> f = q.front();\n                q.pop();\n                int curX = f.first;\n                int curY = f.second;\n                if(curX==x && curY == y)\n                    return res;\n                for(auto dir:dirs) {\n                    int newX = curX + dir.first;\n                    int newY = curY + dir.second;\n                    string key = to_string(newX) + \"_\"+to_string(newY); \n                    if(visited.find(key) == visited.end() && newX >=-1 && newY >=-1) {\n                        visited.insert(key);\n                        q.push({newX, newY});\n                    };\n                }\n            }\n            res++;\n        }\n        return -1;\n\n    }\n};","compare_result":"111111111111111111111111111111111111111111111","title_slug":"minimum-knight-moves","has_notes":false,"flag_type":1}