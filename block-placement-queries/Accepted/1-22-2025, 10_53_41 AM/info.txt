{"id":1517209644,"question_id":3435,"lang":"cpp","lang_name":"C++","time":"2 weeks, 1 day","timestamp":1737572021,"status":10,"status_display":"Accepted","runtime":"789 ms","url":"/submissions/detail/1517209644/","is_pending":"Not Pending","title":"Block Placement Queries","memory":"413.2 MB","code":"class SegTreeNode {\n    public:\n    SegTreeNode* left = NULL;\n    SegTreeNode* right = NULL;\n    int start, end;\n    int info;  // the maximum value of the range\n    bool tag; \n        \n    SegTreeNode(int a, int b, int val) { // init for range [a,b] with val\n        tag = 0;\n        start = a, end = b;\n        if (a==b){\n            info = val;\n            return;\n        }        \n        int mid = (a+b)/2;\n        if (left==NULL) {\n            left = new SegTreeNode(a, mid, val);\n            right = new SegTreeNode(mid+1, b, val);            \n            info = max(left->info, right->info);  // check with your own logic\n        }        \n    }    \n    \n    SegTreeNode(int a, int b, vector<int>& val)  {// init for range [a,b] with the same-size array val\n        tag = 0;\n        info = 0;\n        start = a, end = b;\n        if (a==b){\n            info = val[a];\n            return;\n        }        \n        int mid = (a+b)/2;\n        if (left==NULL) {\n            left = new SegTreeNode(a, mid, val);\n            right = new SegTreeNode(mid+1, b, val);            \n            info = max(left->info, right->info);  // check with your own logic\n        }        \n    } \n    \n    void pushDown(){\n        if (tag==1 && left){\n            left->info = info;\n            right->info = info;\n            left->tag = 1;\n            right->tag = 1;\n            tag = 0;\n        }        \n    } \n    \n    void updateRange(int a, int b, int val) {    // set range [a,b] with val    \n        if (b < start || a > end ) // not covered by [a,b] at all\n            return;        \n        if (a <= start && end <=b)  {// completely covered within [a,b]\n            info = val;\n            tag = 1;\n            return;\n        }\n\n        if (left) {\n            pushDown();        \n            left->updateRange(a, b, val);\n            right->updateRange(a, b, val);\n            info = max(left->info, right->info);  // write your own logic            \n        }        \n    }\n    \n    int queryRange(int a, int b)     {// query the maximum value within range [a,b]\n        if (b < start || a > end ){\n            return INT_MIN/2;  // check with your own logic\n        }\n        if (a <= start && end <=b){\n            return info;  // check with your own logic\n        }          \n        \n        if (left){\n            pushDown();     \n            int ret = max(left->queryRange(a, b), right->queryRange(a, b));        \n            info = max(left->info, right->info);    // check with your own logic\n            return ret;\n        }\n        return info;   // should not reach here\n    }  \n};\n\nclass Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int n = min(50000, (int)queries.size()*3) + 5;\n        SegTreeNode* root = new SegTreeNode(0, n, 0);\n        set<int>Set;\n        Set.insert(0);\n        vector<bool>rets;\n        for (auto q:queries){\n            if (q[0]==1){\n                int x = q[1];\n                Set.insert(x);\n                auto iter = Set.find(x);\n                int a = *prev(iter);\n                root->updateRange(x,x,x-a);\n\n                if (next(iter)!=Set.end()){\n                    int b = *next(iter);\n                    root->updateRange(b,b,b-x);\n                }\n            }else{\n                int x = q[1], sz = q[2];\n                int len = root->queryRange(0, x);\n\n                if (Set.find(x)==Set.end()){\n                    auto iter = Set.lower_bound(x);\n                    int  a = *prev(iter);\n                    len = max(len, x-a);\n                }\n                rets.push_back(len >= sz);\n            }\n        }      \n        return rets;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"block-placement-queries","has_notes":false,"flag_type":1}