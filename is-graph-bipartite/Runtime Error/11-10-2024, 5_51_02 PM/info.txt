{"id":1449159016,"question_id":801,"lang":"cpp","lang_name":"C++","time":"2 months, 4 weeks","timestamp":1731289862,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1449159016/","is_pending":"Not Pending","title":"Is Graph Bipartite?","memory":"N/A","code":"/*\nThere is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] \nis an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. \nThe graph has the following properties:\nThere are no self-edges (graph[u] does not contain u).\nThere are no parallel edges (graph[u] does not contain duplicate values).\nIf v is in graph[u], then u is in graph[v] (the graph is undirected).\nThe graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in \nset A and a node in set B.\nReturn true if and only if it is bipartite.\n\n Example 1:\nInput: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nOutput: false\nExplanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n\nExample 2:\nInput: graph = [[1,3],[0,2],[1,3],[0,2]]\nOutput: true\nExplanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.\n \nConstraints:\ngraph.length == n\n1 <= n <= 100\n0 <= graph[u].length < n\n0 <= graph[u][i] <= n - 1\ngraph[u] does not contain u.\nAll the values of graph[u] are unique.\nIf graph[u] contains v, then graph[v] contains u.\n*/\nclass Solution {\n    unordered_map<int,int> Father;\npublic:\n    bool isBipartite1(vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<int> visited(n, -1); //-1:not visited, 0: grp A, 1: grp B.\n        for(int i=0; i<n; i++) {\n            if(visited[i] != -1) //visited before.\n                continue;\n            queue<pair<int, int>> q; // {node, grp};\n            q.push({i, 0}); //node i, grp 0: A\n            while(!q.empty()) {\n                pair<int, int> f = q.front();\n                int node = f.first;\n                int grp = f.second;\n                q.pop();\n                for(auto& next: graph[node]) {\n                    if(visited[next] != -1) { //visited before\n                        if(visited[next] == grp) //next in the same grp.\n                            return false;\n                    } else {\n                        visited[next] = 1-grp;\n                        q.push({next, 1-grp});\n                    }\n                }\n            }\n        }\n        return true;\n    }\n       bool isBipartite(vector<vector<int>>& graph) {\n            int n = graph.size();\n            for(int i=0; i<n; i++) {\n                Father[i] = i;\n            }\n            for(int i=0; i<n; i++) {\n                int k = graph[i][0];\n                for(auto j: graph[i] ) {\n                    if(FindSet(i) == FindSet(j) )\n                        return false;\n                    Union(k, j);\n                }\n            }\n            return true;\n       }\n       int FindSet(int x) {\n        if(x!=Father[x])\n            Father[x] = FindSet(Father[x]);\n        return Father[x];\n       };\n       void Union(int x, int y) {\n            x = Father[x];\n            y = Father[y];\n            if(x<y)\n                Father[y] = x;\n            else\n                Father[x] = y;\n       }\n};","compare_result":"111111111100000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"is-graph-bipartite","has_notes":false,"flag_type":1}