{"id":1302356058,"question_id":727,"lang":"cpp","lang_name":"C++","time":"7 months, 2 weeks","timestamp":1719521292,"status":10,"status_display":"Accepted","runtime":"132 ms","url":"/submissions/detail/1302356058/","is_pending":"Not Pending","title":"Minimum Window Subsequence","memory":"91.3 MB","code":"class Solution {\npublic:\n/*\nGiven strings s1 and s2, return the minimum contiguous substring part of s1, so that s2 is a subsequence of the part.\nIf there is no such window in s1 that covers all characters in s2, return the empty string \"\". If there are multiple \nsuch minimum-length windows, return the one with the left-most starting index.\n*/\n\n//https://www.cnblogs.com/grandyang/p/8684817.html\n    string minWindow(string S, string T) { //1 <= s1.length <= 2 * 104\n                                            //1 <= s2.length <= 100\n                                            //s1 and s2 consist of lowercase English letters.\n    /*\n    Let dp(i, j) stores the \"largest\" starting index (make the length smallest) of the valid substring W of S[0, i] \n    such that T[0, j] is a subsequence of S. Otherwise, dp(i, j) = -1; So dp(i, j) would be:\n\n    if S[i] == T[j], this means we could borrow the start index from dp(i-1, j-1) to make the current substring valid;\n    else, we only need to borrow the start index from dp(i-1, j) which could either exist or not.\n\n    Finally, go through the last col to find the substring with min length and appears first.\n    */\n      int len_S = S.length();\n        int len_T = T.length();\n        \n        // initialize all value to -1\n        vector<vector<int>> dp(len_S, vector<int>(len_T, -1));\n        \n        // initialize the first col\n        for (int i=0; i<len_S; i++) {\n            if (S[i] == T[0]) {\n                dp[i][0] = i;\n            } else {\n                if (i != 0) {\n                    dp[i][0] = dp[i-1][0];\n                }\n            }\n        }\n        \n        // calculate dp[][]\n        for (int i=1; i<len_S; i++) {\n            for (int j=1; j<len_T; j++) {\n                if (S[i] == T[j]) {\n                    dp[i][j] = dp[i-1][j-1];\n                } else {\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n        \n        // Finally, go through the last col to find the substring with min length and appears first.\n        int begin = -1, min_len = INT_MAX;\n        for (int i=0; i<len_S; i++) {\n            int index = dp[i][len_T-1];\n            if (index != -1) {\n                if (i + 1 - index < min_len) {\n                    begin = index;\n                    min_len = i + 1 - index;\n                }\n            }\n        }\n        return begin == -1 ? \"\" : S.substr(begin, min_len);\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-window-subsequence","has_notes":false,"flag_type":1}