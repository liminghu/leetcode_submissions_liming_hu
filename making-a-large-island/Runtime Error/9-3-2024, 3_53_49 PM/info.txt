{"id":1378230217,"question_id":854,"lang":"cpp","lang_name":"C++","time":"5Â months","timestamp":1725404029,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1378230217/","is_pending":"Not Pending","title":"Making A Large Island","memory":"N/A","code":"/*\nYou are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\nReturn the size of the largest island in grid after applying this operation.\nAn island is a 4-directionally connected group of 1s.\n*/\nclass Solution {\npublic:\n\n    int largestIsland(vector<vector<int>>& grid) {\n        /*  n == grid.length\n            n == grid[i].length\n            1 <= n <= 500\n            grid[i][j] is either 0 or 1.\n        */\n        int n = grid.size();\n        vector<vector<int>> visited(n, vector<int>(n, -1));\n        queue<pair<int,int>> q;\n        vector<pair<int,int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        int numIslands = 0;\n        unordered_map<int, int> mp; //num_islands, size\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(grid[i][j] == 1 && visited[i][j] == -1) {\n                    int size = 1;\n                    visited[i][j] = numIslands;\n\n                    cout << \"newIsland i= \" << i <<\" j= \" << j <<endl;\n                    q.push({i, j});\n                    while(~q.empty()) {\n                        pair<int, int> cur = q.front();\n                        cout << \"cur i= \" << cur.first <<\" cur j= \" << cur.second <<endl;\n                        q.pop();\n\n                        for(int k=0; k<dirs.size(); k++) {\n                            cout <<\"direction: \" << dirs[k].first <<\" \" << dirs[k].second <<endl;\n                            long neighbor_i = cur.first + dirs[k].first;\n                            long neighbor_j = cur.second + dirs[k].second;\n                            if( (neighbor_i >= 0 && neighbor_i < n && neighbor_j >=0 && neighbor_j < n) && visited[neighbor_i][neighbor_j] == -1) {\n                                cout << \"neighbor:  \"<< neighbor_i << \" \"<< neighbor_j << endl;\n                                q.push( make_pair(neighbor_i, neighbor_j) );\n                                visited[ neighbor_i ][ neighbor_j ] = numIslands;\n                                size++;\n                            };\n                        };\n                    };\n                    mp[numIslands] = size;\n                    numIslands++;\n                };\n            };\n        };\n\n         int res = -1;\n         for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(grid[i][j] == 0 && visited[i][j] == -1) {\n                    int numIsland = visited[i][j];\n                    int size = mp[numIsland];\n                    mp[numIsland] = mp[numIsland]+1;\n                    res = max(res, mp[numIsland]);\n                    for(auto dir:dirs) {\n                        if(i+dir.first>=0 && i+dir.first<n && j+dir.second>=0 && j+dir.second<n && visited[i+dir.first][j+dir.second] != -1) {\n                            int numIslandNeib = visited[i+dir.first][j+dir.second];\n                            int sizeNeib = mp[numIslandNeib];\n                            mp[numIslandNeib] = mp[numIslandNeib]+size;\n                            mp[numIsland] += sizeNeib;\n                            res = max(res, mp[numIsland]);\n                        };\n                    };\n                \n                }\n            }\n         }\n         return res;       \n\n\n\n\n    }\n};","compare_result":"000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"making-a-large-island","has_notes":false,"flag_type":1}