{"id":1378253839,"question_id":854,"lang":"cpp","lang_name":"C++","time":"5Â months","timestamp":1725407317,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1378253839/","is_pending":"Not Pending","title":"Making A Large Island","memory":"N/A","code":"/*\nYou are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\nReturn the size of the largest island in grid after applying this operation.\nAn island is a 4-directionally connected group of 1s.\n*/\nclass Solution {\npublic:\n\n    int largestIsland(vector<vector<int>>& grid) {\n        /*  n == grid.length\n            n == grid[i].length\n            1 <= n <= 500\n            grid[i][j] is either 0 or 1.\n        */\n        int n = grid.size();\n        vector<vector<int>> visited(n, vector<int>(n, -1));\n        queue<pair<int,int>> q;\n        vector<pair<int,int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        int numIslands = 0;\n        unordered_map<int, int> mp; //num_islands, size\n        mp[-1] = 1;\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(grid[i][j] == 1 && visited[i][j] == -1) {\n                    int size = 1;\n                    visited[i][j] = numIslands;\n\n                    //cout << \"newIsland i= \" << i <<\" j= \" << j <<endl;\n                    q.push(make_pair(i, j));\n                    while(!q.empty()) {\n                        pair<int, int> cur = q.front();\n                        //cout << \"cur i= \" << cur.first <<\" cur j= \" << cur.second <<endl;\n                        q.pop();\n                        //cout << \"q size: \" << q.size() << endl; \n\n                        for(int k=0; k<dirs.size(); k++) {\n                           // cout <<\"direction: \" << dirs[k].first <<\" \" << dirs[k].second <<endl;\n                            long neighbor_i = cur.first + dirs[k].first;\n                            long neighbor_j = cur.second + dirs[k].second;\n                            if( (neighbor_i >= 0 && neighbor_i < n && neighbor_j >= 0 && neighbor_j < n) && grid[neighbor_i][neighbor_j] == 1 && visited[neighbor_i][neighbor_j] == -1) {\n                                //cout << \"neighbor:  \"<< neighbor_i << \" \"<< neighbor_j << endl;\n                                q.push( make_pair(neighbor_i, neighbor_j) );\n                                visited[ neighbor_i ][ neighbor_j ] = numIslands;\n                                size++;\n                            };\n                        };\n                    };\n                    mp[numIslands] = size;\n                    numIslands++;\n                };\n            };\n        };\n\n         int res = -1;\n         for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(grid[i][j] == 0 && visited[i][j] == -1) { //the land can be changed.\n\n                    cout << \"newIsland i= \" << i <<\" j= \" << j <<endl;\n                    int numIsland = visited[i][j]; //-1\n                    int size = mp[numIsland]; //1\n                    //mp[numIsland] = mp[numIsland]+1;\n                    res = max(res, mp[numIsland]);\n\n                    cout << \"res= \" <<res << endl;\n                    int sizeNeib = 0;\n                    unordered_set<int> s;\n                    for(auto dir:dirs) { //find its four neighbors.\n                        if(i+dir.first>=0 && i+dir.first<n && j+dir.second>=0 && j+dir.second<n && visited[i+dir.first][j+dir.second] != -1) {\n                            int neinumIsland = visited[i+dir.first][j+dir.second]; \n                            if(!s.contains(neinumIsland)) {\n                                s.insert(neinumIsland);\n                                cout << \"neighbor:  \"<< i+dir.first << \" \"<< j+dir.second << endl;                            \n                                sizeNeib += mp[neinumIsland];\n\n                                //mp[numIslandNeib] = mp[numIslandNeib]+size; //+1.\n                                // mp[numIsland] += sizeNeib; //mp[-1] = 1 + sizeNeib.\n                           }\n                        };\n                    };\n                    res = max(res, mp[numIsland]+sizeNeib);\n                    cout << \"res= \" <<res << endl;\n                \n                } else { //no land changed.\n                    if(grid[i][j] == 1) {\n                        int numIsland = visited[i][j]; \n                        int size = mp[numIsland]; \n                        res = max(res, size);\n                    };\n                }\n            }\n         }\n         return res;       \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111110000","title_slug":"making-a-large-island","has_notes":false,"flag_type":1}