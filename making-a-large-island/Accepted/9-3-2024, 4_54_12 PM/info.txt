{"id":1378256148,"question_id":854,"lang":"cpp","lang_name":"C++","time":"5Â months","timestamp":1725407652,"status":10,"status_display":"Accepted","runtime":"460 ms","url":"/submissions/detail/1378256148/","is_pending":"Not Pending","title":"Making A Large Island","memory":"162.6 MB","code":"/*\nYou are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\nReturn the size of the largest island in grid after applying this operation.\nAn island is a 4-directionally connected group of 1s.\n*/\nclass Solution {\npublic:\n    int largestIsland(vector<vector<int>>& grid) {\n        /*  n == grid.length\n            n == grid[i].length\n            1 <= n <= 500\n            grid[i][j] is either 0 or 1.\n        */\n        int n = grid.size();\n        vector<vector<int>> visited(n, vector<int>(n, -1));\n        queue<pair<int,int>> q;\n        vector<pair<int,int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        int numIslands = 0;\n        unordered_map<int, int> mp; //num_islands, size\n        mp[-1] = 1;\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(grid[i][j] == 1 && visited[i][j] == -1) {\n                    int size = 1;\n                    visited[i][j] = numIslands;\n                    q.push(make_pair(i, j));\n                    while(!q.empty()) {\n                        pair<int, int> cur = q.front();\n                        q.pop();\n                        for(int k=0; k<dirs.size(); k++) {\n                            long neighbor_i = cur.first + dirs[k].first;\n                            long neighbor_j = cur.second + dirs[k].second;\n                            if( (neighbor_i >= 0 && neighbor_i < n && neighbor_j >= 0 && neighbor_j < n) && grid[neighbor_i][neighbor_j] == 1 && visited[neighbor_i][neighbor_j] == -1) {\n                                q.push( make_pair(neighbor_i, neighbor_j) );\n                                visited[ neighbor_i ][ neighbor_j ] = numIslands;\n                                size++;\n                            };\n                        };\n                    };\n                    mp[numIslands] = size;\n                    numIslands++;\n                };\n            };\n        };\n\n         int res = -1;\n         for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(grid[i][j] == 0 && visited[i][j] == -1) { //the land can be changed.\n                    int numIsland = visited[i][j]; //-1\n                    int size = mp[numIsland]; //1\n                    res = max(res, mp[numIsland]);\n\n                    int sizeNeib = 0;\n                    unordered_set<int> s;\n                    for(auto dir:dirs) { //find its four neighbors.\n                        if(i+dir.first>=0 && i+dir.first<n && j+dir.second>=0 && j+dir.second<n && visited[i+dir.first][j+dir.second] != -1) {\n                            int neinumIsland = visited[i+dir.first][j+dir.second]; \n                            if(!s.contains(neinumIsland)) {\n                                s.insert(neinumIsland);                         \n                                sizeNeib += mp[neinumIsland];\n                           }\n                        };\n                    };\n                    res = max(res, mp[numIsland]+sizeNeib);                \n                } else { //no land changed.\n                    if(grid[i][j] == 1) {\n                        int numIsland = visited[i][j]; \n                        int size = mp[numIsland]; \n                        res = max(res, size);\n                    };\n                }\n            }\n         }\n         return res;       \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"making-a-large-island","has_notes":false,"flag_type":1}