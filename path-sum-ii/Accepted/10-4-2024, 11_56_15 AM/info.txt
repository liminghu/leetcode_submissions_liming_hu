{"id":1411895083,"question_id":113,"lang":"cpp","lang_name":"C++","time":"4Â months","timestamp":1728068175,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1411895083/","is_pending":"Not Pending","title":"Path Sum II","memory":"21.9 MB","code":"/*\nGiven the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values \nin the path equals targetSum. Each path should be returned as a list of the node values, not node references.\nA root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.\n\nExample 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: [[5,4,11,2],[5,8,4,5]]\nExplanation: There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n\nExample 2:\nInput: root = [1,2,3], targetSum = 5\nOutput: []\n\nExample 3:\nInput: root = [1,2], targetSum = 0\nOutput: []\n \nConstraints:\nThe number of nodes in the tree is in the range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000\n*/\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        if( root == NULL )\n            return {};\n        if(root->left == NULL && root->right == NULL ) {\n            if(root->val == targetSum) \n                return {{root->val}};\n            else\n                return {};\n        }\n        vector<vector<int>> left = pathSum(root->left, targetSum - root->val );\n        for(int i=0; i<left.size(); i++) {\n            left[i].insert(left[i].begin(), root->val);\n        }\n\n        vector<vector<int>> right = pathSum(root->right, targetSum - root->val );\n        for(int i=0; i<right.size(); i++) {\n            right[i].insert(right[i].begin(), root->val);\n        }\n\n        left.insert(left.end(), right.begin(), right.end());\n        return left;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"path-sum-ii","has_notes":false,"flag_type":1}