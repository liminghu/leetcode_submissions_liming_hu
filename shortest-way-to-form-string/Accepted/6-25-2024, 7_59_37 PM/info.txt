{"id":1300410522,"question_id":1051,"lang":"cpp","lang_name":"C++","time":"7 months, 2 weeks","timestamp":1719370777,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1300410522/","is_pending":"Not Pending","title":"Shortest Way to Form String","memory":"7.5 MB","code":"class Solution {\npublic:\n/*\nA subsequence of a string is a new string that is formed from the original string by deleting some \n(can be none) of the characters without disturbing the relative positions of the remaining characters. \n(i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\n\nGiven two strings source and target, return the minimum number of subsequences of source such that their \nconcatenation equals target. If the task is impossible, return -1.\n*/\n    int shortestWay(string source, string target) {\n         //1 <= source.length, target.length <= 1000\n        //source and target consist of lowercase English letters.\n        int sz1 = source.length();\n        int sz2 = target.length();\n        //look for maximum subsequence\n        int i = 0;\n        int begin = 0; \n        int j = 0;\n        int count = 0;\n        \n        while( j < sz2 ) {\n            j = begin;\n            while( i < sz1 ) {\n                if(source[i] == target[j]) \n                    j++;\n                i++;\n            }\n            if(j == begin)\n                return -1;\n            else\n                count++;\n            i=0;\n            begin = j;\n        }\n        return count;       \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111","title_slug":"shortest-way-to-form-string","has_notes":false,"flag_type":1}