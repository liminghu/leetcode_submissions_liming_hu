{"id":1404414034,"question_id":63,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1727482002,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/1404414034/","is_pending":"Not Pending","title":"Unique Paths II","memory":"10.6 MB","code":"/*\nYou are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). \nThe robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or \nright at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square \nthat is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 109.\nm == obstacleGrid.length\nn == obstacleGrid[i].length\n1 <= m, n <= 100\nobstacleGrid[i][j] is 0 or 1.\n*/\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        //The robot can only move either down or right at any point in time.\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n        vector<vector<uint32_t>> dp(m, vector<uint32_t>(n,0));\n\n        for(int i=m-1; i>=0; i--) {\n            for(int j=n-1; j>=0; j--) {\n                if(obstacleGrid[i][j] == 0) {\n                    if(i==m-1 && j==n-1)\n                        dp[m-1][n-1] = 1;\n                    else if(i==m-1) //j<=n-2;\n                        dp[i][j] = dp[i][j+1];\n                    else if(j==n-1) //i<=m-2;\n                        dp[i][j] = dp[i+1][j];\n                    else\n                        dp[i][j] = dp[i+1][j] + dp[i][j+1];\n                };\n            }\n        }\n        return dp[0][0];\n    }\n};","compare_result":"11111111111111111111111111111111111111111","title_slug":"unique-paths-ii","has_notes":false,"flag_type":1}