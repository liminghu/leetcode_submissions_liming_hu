{"id":400728649,"question_id":131,"lang":"cpp","lang_name":"C++","time":"4 years, 4 months","timestamp":1601074486,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/400728649/","is_pending":"Not Pending","title":"Palindrome Partitioning","memory":"8.9 MB","code":"//DFS+ backtracking\nclass Solution {\npublic:\n  vector<vector<string>> partition(string s) {\n\t  int n = s.length();\n\t  vector<vector<string>> ans;\n\t  vector<string> cur;\n\t  function<void(int)> dfs = [&](int start) {\n\t\tif(start == n) {\n\t\t\tans.push_back(cur);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i=start; i<n; i++) {\n\t\t\tif(!isPalindrome(s, start, i)) continue;\n\t\t\tcur.push_back(s.substr(start, i-start+1));\n\t\t\tdfs(i+1);\n\t\t\tcur.pop_back();\n\t\t}\n\t  };\n\t  dfs(0);\n\t  return ans;\n   } \n   \n   bool isPalindrome(const string& s, int l, int r) {\n\twhile(l < r)\n\t\tif(s[l++] != s[r--] ) return false;\n\treturn true;\n  }\n};","compare_result":"1111111111111111111111","title_slug":"palindrome-partitioning","has_notes":false,"flag_type":1}