{"id":1405713954,"question_id":106,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1727584463,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1405713954/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"27.5 MB","code":"/*\nGiven two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and \npostorder is the postorder traversal of the same tree, construct and return the binary tree.\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.\n*/\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    unordered_map<int, int> mp;\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        //inorder: left, root, right\n        //postorder: left, right, root.\n        for(int i=0; i<inorder.size(); i++) \n            mp[ inorder[i] ] = i;\n        \n        return tree(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1);\n    };\n    TreeNode* tree(vector<int>& inorder, int s1, int e1, vector<int>& postorder, int s2, int e2) {\n        if (s1>e1 || s2>e2)\n            return NULL;\n        TreeNode* node = new TreeNode(postorder[e2]);\n        int io_loc = mp[node->val]; //root\n\n        node->left = tree(inorder, s1, io_loc-1, postorder, s2, s2+(io_loc-1-s1) );\n        node->right = tree(inorder, io_loc+1, e1, postorder, s2+(io_loc-1-s1)+1,   e2-1);\n        return node;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal","has_notes":false,"flag_type":1}