{"id":1321287898,"question_id":2306,"lang":"cpp","lang_name":"C++","time":"6 months, 3 weeks","timestamp":1721006414,"status":10,"status_display":"Accepted","runtime":"792 ms","url":"/submissions/detail/1321287898/","is_pending":"Not Pending","title":"Create Binary Tree From Descriptions","memory":"312.5 MB","code":"/*You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates \nthat parenti is the parent of childi in a binary tree of unique values. Furthermore,\nIf isLefti == 1, then childi is the left child of parenti.\nIf isLefti == 0, then childi is the right child of parenti.\nConstruct the binary tree described by descriptions and return its root.\nThe test cases will be generated such that the binary tree is valid.\n*/\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\n        /*  1 <= descriptions.length <= 104\n            descriptions[i].length == 3\n            1 <= parenti, childi <= 105\n            0 <= isLefti <= 1\n        */\n        TreeNode* root;\n        int sz = descriptions.size();\n        unordered_map<int, vector<pair<int, int>>> children;\n        unordered_set<int> root_set;\n        for(int i=0; i<sz; i++) {\n            children[descriptions[i][0]].push_back({descriptions[i][1], descriptions[i][2]} ); //[parenti, childi, isLefti]\n            root_set.insert(descriptions[i][1]); //insert node which has parent.\n        };\n        int root_val = -1;\n        for(auto child: children) {\n            if(root_set.find(child.first)== root_set.end()) {\n                root_val = child.first;\n                break;\n            }\n        }\n\n        root = new TreeNode(root_val);\n        //build_tree(root, children);\n        queue<TreeNode*> qu;\n        qu.push(root);\n        while(!qu.empty()) {\n            TreeNode* cur_node = qu.front();\n            qu.pop();\n\n            int root_val = cur_node->val;\n            vector<pair<int, int>> child_root = children[root_val];\n            for(int i=0; i<child_root.size(); i++) {\n                if(child_root[i].second)  {//isleft\n                    TreeNode* left = new TreeNode(child_root[i].first);\n                    cur_node->left = left;\n                    //build_tree(root->left, children);\n                    qu.push(left);\n                } else {\n                    TreeNode* right = new TreeNode(child_root[i].first);\n                    cur_node->right = right;\n                    //build_tree(root->right, children);\n                    qu.push(right);\n                }\n            }\n        }\n\n        return root;\n\n    }\n\n    void build_tree(TreeNode* root, unordered_map<int, vector<pair<int, int>>> children) {\n        int root_val = root->val;\n        vector<pair<int, int>> child_root = children[root_val];\n        for(int i=0; i<child_root.size(); i++) {\n            if(child_root[i].second)  {//isleft\n                TreeNode* left = new TreeNode(child_root[i].first);\n                root->left = left;\n                build_tree(root->left, children);\n            } else {\n                TreeNode* right = new TreeNode(child_root[i].first);\n                root->right = right;\n                build_tree(root->right, children);\n            }\n        }\n    };\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"create-binary-tree-from-descriptions","has_notes":false,"flag_type":1}