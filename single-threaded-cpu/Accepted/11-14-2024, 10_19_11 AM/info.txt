{"id":1452849365,"question_id":1962,"lang":"cpp","lang_name":"C++","time":"2 months, 3 weeks","timestamp":1731608351,"status":10,"status_display":"Accepted","runtime":"87 ms","url":"/submissions/detail/1452849365/","is_pending":"Not Pending","title":"Single-Threaded CPU","memory":"130.2 MB","code":"class Solution {\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq; //pair: processing time, task idx.\n        vector<array<int,3>> sortedTasks; //enqueue time, processing time, task idx.\n        for(int i=0; i<tasks.size(); i++)\n            sortedTasks.push_back({tasks[i][0], tasks[i][1], i});\n        sort(sortedTasks.begin(), sortedTasks.end());\n        vector<int> tasksProcessingOrder;\n        long long currTime = 0;\n        int taskIdx = 0;\n        while(taskIdx <tasks.size() || !pq.empty() ) {\n            if(pq.empty() && currTime < sortedTasks[taskIdx][0])\n                currTime = sortedTasks[taskIdx][0];\n            while(taskIdx<sortedTasks.size() && currTime >= sortedTasks[taskIdx][0]) {\n                pq.push({sortedTasks[taskIdx][1], sortedTasks[taskIdx][2]});\n                taskIdx++;\n            };\n            if(!pq.empty()) {\n                auto [processTime, idx] = pq.top();\n                pq.pop();\n                currTime += processTime;\n                tasksProcessingOrder.push_back(idx);\n            }\n        }\n        return tasksProcessingOrder;\n    }\n};","compare_result":"111111111111111111111111111111111111111","title_slug":"single-threaded-cpu","has_notes":false,"flag_type":1}