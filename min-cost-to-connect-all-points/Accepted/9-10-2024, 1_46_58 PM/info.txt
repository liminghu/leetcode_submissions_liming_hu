{"id":1385857719,"question_id":1706,"lang":"cpp","lang_name":"C++","time":"4 months, 4 weeks","timestamp":1726001218,"status":10,"status_display":"Accepted","runtime":"180 ms","url":"/submissions/detail/1385857719/","is_pending":"Not Pending","title":"Min Cost to Connect All Points","memory":"167.1 MB","code":"/*\nYou are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.\n1 <= points.length <= 1000\n-106 <= xi, yi <= 106\nAll pairs (xi, yi) are distinct.\n*/\nclass Solution {\npublic:\n    int visited[1000];\n/*    int Father[1000];\n    int findFather(int x) {\n        if(Father[x] != x ) {\n            Father[x] = findFather(Father[x]);\n        };\n        return Father[x];\n    }\n    void Union(int x, int y) {\n        x = Father[x];\n        y = Father[y];\n        if(x < y ) \n            Father[y] = x;\n        else\n            Father[x] = y;\n    }*/\n\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        //Prim\n        int n = points.size();\n        vector<vector<pair<int,int>>> edges(n);\n        for(int i=0; i<n; i++) {\n            for(int j=i+1; j<n; j++) {\n                int dist = abs(points[i][0]-points[j][0]) +  abs(points[i][1]-points[j][1]);\n                edges[i].push_back({dist, j});\n                edges[j].push_back({dist, i});\n            }\n        }\n        priority_queue<pair<int,int>, vector<pair<int,int>>,greater<pair<int,int>>> pq(edges[0].begin(), edges[0].end());\n        visited[0] = 1;\n        int result = 0;\n        for(int k=0; k<n-1; k++) {\n            while(!pq.empty() && visited[pq.top().second] == 1 ) \n                pq.pop();\n            int next = pq.top().second;\n            visited[next] = 1;\n            result += pq.top().first;\n            pq.pop();\n            for(auto edge: edges[next]) \n                pq.push(edge);\n        }\n        return result;\n\n/*        //Kruskal\n        int n = points.size();\n        for(int i=0; i<n; i++) {\n            Father[i] = i;\n        }\n\n        priority_queue<array<int,3>, vector<array<int,3>>,greater<array<int,3>>> edges;\n        for(int i=0; i<n; i++) {\n            for(int j=i+1; j<n; j++) {\n                int dist = abs(points[i][0]-points[j][0]) +  abs(points[i][1]-points[j][1]);\n                edges.push({dist, i, j});\n            }\n        }    \n        int result = 0;\n        int count = 1;\n        while(count < n) { // n-1 edges. n points.\n            auto edge = edges.top();\n            edges.pop();\n            int s = edge[1];\n            int t = edge[2];\n            int dist = edge[0];\n            if(findFather(s)!= findFather(t)) {\n                Union(s,t);\n                count++;\n                result += dist;\n                if(count == n)\n                    break;\n            }\n        }\n        return result;*/\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"min-cost-to-connect-all-points","has_notes":false,"flag_type":1}