{"id":1288578464,"question_id":658,"lang":"cpp","lang_name":"C++","time":"7 months, 3 weeks","timestamp":1718410306,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1288578464/","is_pending":"Not Pending","title":"Find K Closest Elements","memory":"N/A","code":"class Solution {\npublic:\n/*\nGiven a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.\n\nAn integer a is closer to x than an integer b if:\n\n|a - x| < |b - x|, or\n|a - x| == |b - x| and a < b\n\n*/\n\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        /*int sz = arr.size();\n        for(int i=0; i<sz; i++)\n            arr[i] = arr[i]-x;\n        priority_queue<int, vector<int>, decltype([](int first, int second){ return (abs(first) < abs(second)) || (abs(first) == abs(second) && first < second ); })\n            > kClosest; //max at the top.\n\n        for(int i=0; i<sz; i++) {\n            kClosest.push(arr[i]); \n        };\n\n        while(kClosest.size()>k) \n            kClosest.pop();\n        \n        vector<int> ans;\n        while(!kClosest.empty()) {\n            ans.push_back(kClosest.top()+x);\n            kClosest.pop();\n        } ;\n\n        sort(ans.begin(), ans.end());\n        return ans;*/\n\n        int sz = arr.size();\n        //initialize binary search bounds.\n        int left = 0;\n        int right = sz - k;\n\n        //binary search.\n        while(left <right) {\n            int mid = (left+right)/2;\n            //If the element at arr[mid] is closer to x than arr[mid + k], \n            //then that means arr[mid + k], as well as every element to the right of it can never be in the answer. \n            //This means we should move our right pointer to avoid considering them. The logic is the same vice-versa - if arr[mid + k] is closer to x, then move the left pointer.\n            if (abs(arr[mid+k]-x) < abs(arr[mid]-x))  { //(x-arr[mid]>arr[mid+k]-x) { //(abs(x-arr[mid]) < abs(arr[mid+k]-x)) || (abs(x-arr[mid]) == abs(arr[mid+k]-x) && arr[mid] < arr[mid+k] )\n                left = mid+1;\n            } else {\n                right = mid;\n            }\n        }\n        vector<int> ans;\n        for(int i=left; i<left+k; i++) \n        ans.push_back(arr[i]);\n\n        return ans;\n        \n    }\n};","compare_result":"1111111111111111111110111111111111111111111111111111111111111111111101","title_slug":"find-k-closest-elements","has_notes":false,"flag_type":1}