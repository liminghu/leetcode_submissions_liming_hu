{"id":1402097136,"question_id":86,"lang":"cpp","lang_name":"C++","time":"4 months, 2 weeks","timestamp":1727285046,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1402097136/","is_pending":"Not Pending","title":"Partition List","memory":"14.9 MB","code":"/*\nGiven the head of a linked list and a value x, partition it such that all nodes \nless than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nThe number of nodes in the list is in the range [0, 200].\n-100 <= Node.val <= 100\n-200 <= x <= 200\n*/\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        if(head == NULL)\n            return head;\n        if(head->next == NULL)\n            return head;\n        \n        ListNode* fakehead = new ListNode(INT_MAX, head);\n        //find the first node whose value is greater than or equal to x.\n        ListNode* cur = head;\n        ListNode* prev = fakehead;\n        while(cur && cur->val < x) {\n            prev = cur;\n            cur = cur->next;\n        };\n        //cur: null or cur->val >= x\n        \n        //move all the nodes whose value is less than x before that node.\n        if(cur == NULL || cur->next == NULL)\n            return fakehead->next;\n        ListNode* tomove = cur;\n        ListNode* prev_tomove = cur;\n        while(tomove && tomove->val >= x) { //find the first node to move.\n            prev_tomove = tomove;\n            tomove = tomove->next;\n        }   \n\n        while(tomove) {\n            prev_tomove->next = tomove->next; //move the node.\n            prev->next = tomove;\n            prev = tomove;\n            tomove->next = cur;\n\n            tomove = prev_tomove->next; //to find the next tomove.\n            while(tomove && tomove->val >= x) {\n                prev_tomove = tomove;\n                tomove = tomove->next;\n            }\n        }\n        return fakehead->next;\n\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"partition-list","has_notes":false,"flag_type":1}