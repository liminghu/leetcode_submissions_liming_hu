{"id":1370715757,"question_id":1036,"lang":"cpp","lang_name":"C++","time":"5 months, 1 week","timestamp":1724816845,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1370715757/","is_pending":"Not Pending","title":"Rotting Oranges","memory":"16.3 MB","code":"/*\nYou are given an m x n grid where each cell can have one of three values:\n0 representing an empty cell,\n1 representing a fresh orange, or\n2 representing a rotten orange.\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. \nIf this is impossible, return -1.\n*/\nclass Solution {\npublic:\n    int orangesRotting(vector<vector<int>>& grid) {\n        /*  m == grid.length\n            n == grid[i].length\n            1 <= m, n <= 10\n            grid[i][j] is 0, 1, or 2.\n        */\n        int m = grid.size();\n        int n = grid[0].size();\n        int mins = 0;\n        int num_good = 0;\n        queue<pair<int, int>> q;\n        for(int i=0; i<m; i++) {\n            for (int j=0; j<n; j++) {\n                if(grid[i][j] == 1)\n                    num_good++; \n                else if(grid[i][j] == 2) \n                    q.push({i,j});\n            }\n        };\n\n        q.push({-1, -1}); //mark the end of current timestamp.\n\n        if(num_good == 0)\n            return 0;\n        \n        while(!q.empty()) {    \n            pair<int,int> cur = q.front();\n            q.pop();\n            int i = cur.first;\n            int j = cur.second;\n            if(i == -1) {\n                mins++;\n                if(!q.empty()) {\n                    q.push({-1, -1});\n                }\n            } else {\n                //4 neighbors.\n                //grid[i+1][j]\n                if(i+1<m && grid[i+1][j] == 1) {\n                    grid[i+1][j] = 2;\n                    num_good--;\n                    q.push({i+1, j});\n                } \n                //grid[i-1][j] \n                if(i-1>=0 && grid[i-1][j] == 1) {\n                    grid[i-1][j] = 2;\n                    num_good--;\n                    q.push({i-1, j});\n                } \n                //grid[i][j+1] \n                if(j+1<n && grid[i][j+1] == 1) {\n                    grid[i][j+1] = 2;\n                    num_good--;\n                    q.push({i, j+1});\n                } \n                //grid[i][j-1] \n                if(j-1>=0 && grid[i][j-1] == 1) {\n                    grid[i][j-1] = 2;\n                    num_good--;\n                    q.push({i, j-1});\n                } \n            }\n        }//end while\n\n        return num_good == 0? mins-1: -1;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"rotting-oranges","has_notes":false,"flag_type":1}