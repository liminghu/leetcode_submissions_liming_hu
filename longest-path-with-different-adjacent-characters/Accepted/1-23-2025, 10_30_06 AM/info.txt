{"id":1518294095,"question_id":2364,"lang":"cpp","lang_name":"C++","time":"2Â weeks","timestamp":1737657006,"status":10,"status_display":"Accepted","runtime":"1378 ms","url":"/submissions/detail/1518294095/","is_pending":"Not Pending","title":"Longest Path With Different Adjacent Characters","memory":"350.6 MB","code":"class Solution {\npublic:\n    int longestPath(vector<int>& parent, string s) {\n        //Return the length of the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them.\n        unordered_map<int, vector<int>> children; //parent node, children node.\n        unordered_map<int, int> len; //node id, length.\n        int maxPath = 1;\n        int n = parent.size();\n        for(int i=0; i<n; i++) {\n            if(parent[i] != -1) {\n                children[ parent[i] ].push_back(i);\n            };\n        };\n        dfs(0, s, children, len, maxPath);\n        return maxPath;\n    }\n    void dfs(int node, string& s, unordered_map<int, vector<int>>& children, unordered_map<int, int>& len, int& maxPath) {\n        if(children[node].size()==0) {\n            len[node] = 1;\n            return;\n        };\n        int curPath = 1;\n        vector<int> temp;\n        for(int child: children[node]) {\n            dfs(child, s, children, len, maxPath);\n            if(s[child] != s[node]) {\n                curPath = max(curPath, len[child]+1);\n                temp.push_back(len[child]);\n            };\n        }\n        len[node] = curPath;\n        sort(temp.rbegin(), temp.rend()); //descreasing\n        if(temp.size() >= 2) {\n            maxPath = max(maxPath, temp[0]+temp[1]+1);\n        } else if(temp.size()==1) {\n            maxPath = max(maxPath, temp[0]+1);\n        } //else\n          //  maxPath = max(maxPath, 1);\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-path-with-different-adjacent-characters","has_notes":false,"flag_type":1}