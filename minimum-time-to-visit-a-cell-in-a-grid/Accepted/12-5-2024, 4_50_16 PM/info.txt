{"id":1471431796,"question_id":2711,"lang":"cpp","lang_name":"C++","time":"2Â months","timestamp":1733446216,"status":10,"status_display":"Accepted","runtime":"1247 ms","url":"/submissions/detail/1471431796/","is_pending":"Not Pending","title":"Minimum Time to Visit a Cell In a Grid","memory":"264 MB","code":"class Solution {\npublic:\n    int minimumTime(vector<vector<int>>& grid) {\n        if(grid[0][1] > 1 && grid[1][0]>1)\n            return -1;\n        int rows = grid.size();\n        int cols = grid[0].size();\n        vector<vector<int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq; //min\n        pq.push({0, 0, 0}); //{t, r, c}\n        while(!pq.empty()) {\n            vector<int> curr = pq.top();\n            pq.pop();\n            int t = curr[0];\n            int r = curr[1];\n            int c = curr[2];\n            if(r == rows-1 && c==cols-1 )\n                return t;\n            if(visited[r][c])\n                continue;\n            visited[r][c] = true;\n            for(auto dir:dirs) {\n                int nr = r+dir[0];\n                int nc = c+dir[1];\n                if(nr<0 || nc<0 || nr>=rows || nc>=cols)\n                    continue;\n                if(visited[nr][nc])\n                    continue;\n                int wait = (grid[nr][nc]-t)%2 == 0; //Since it takes an even number of seconds to \"stand still\" when moving back and forth, \n                                                    //we need to wait for an extra second if we want to move after an odd number of seconds\n                int nt = max(grid[nr][nc]+wait, t+1);\n                pq.push({nt, nr, nc});    \n            }\n        }\n        return -1;\n    }\n};","compare_result":"11111111111111111111111111111111111111111","title_slug":"minimum-time-to-visit-a-cell-in-a-grid","has_notes":false,"flag_type":1}