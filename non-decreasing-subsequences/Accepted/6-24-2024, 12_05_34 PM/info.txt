{"id":1299106886,"question_id":491,"lang":"cpp","lang_name":"C++","time":"7 months, 2 weeks","timestamp":1719255934,"status":10,"status_display":"Accepted","runtime":"36 ms","url":"/submissions/detail/1299106886/","is_pending":"Not Pending","title":"Non-decreasing Subsequences","memory":"28.9 MB","code":"class Solution {\npublic:\n/*\nGiven an integer array nums, return all the different possible non-decreasing subsequences \nof the given array with at least two elements. \nYou may return the answer in any order.\n*/\n    vector<vector<int>> ans;\n    vector<int> path;\n\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n\n        int start = 0;\n        backtrack(nums, start);\n\n        return ans;        \n    }\n\n    void backtrack(vector<int>& nums, int start) {\n        unordered_map<int, int> dict; //record the current level: is the number used before? \n\n        if( path.size()>=2) {\n            ans.push_back(path);\n        };\n        if(start == nums.size() ) {\n            return;\n        };\n\n        for(int i=start; i<nums.size(); i++) {\n            if(path.size() >0 && path.back() > nums[i])\n                continue;\n            if(dict.find(nums[i])!=dict.end())\n                continue;\n            path.push_back(nums[i]);\n            dict[nums[i]] = i;\n            backtrack(nums, i+1);\n            path.pop_back();\n        }\n\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"non-decreasing-subsequences","has_notes":false,"flag_type":1}