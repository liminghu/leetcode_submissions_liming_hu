{"id":1449059671,"question_id":922,"lang":"cpp","lang_name":"C++","time":"2 months, 4 weeks","timestamp":1731277357,"status":10,"status_display":"Accepted","runtime":"60 ms","url":"/submissions/detail/1449059671/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"75.5 MB","code":"/*\nWe want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, \nand they should not go into the same group.\nGiven the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the \nperson labeled bi, return true if it is possible to split everyone into two groups in this way.\n\nExample 1:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\nOutput: true\nExplanation: The first group has [1,4], and the second group has [2,3].\n\nExample 2:\nInput: n = 3, dislikes = [[1,2],[1,3],[2,3]]\nOutput: false\nExplanation: We need at least 3 groups to divide them. We cannot put them in two groups.\n \nConstraints:\n1 <= n <= 2000\n0 <= dislikes.length <= 104\ndislikes[i].length == 2\n1 <= ai < bi <= n\nAll the pairs of dislikes are unique.\n*/\nclass Solution {\nvector<vector<int>> adj_;\nvector<int> colors_;\npublic:\n    //We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group.\n    bool possibleBipartition1(int n, vector<vector<int>>& dislikes) { //dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi\n        adj_ = vector<vector<int>>(n);\n        for(auto d:dislikes) {\n            adj_[ d[0] - 1 ].push_back(d[1] - 1);\n            adj_[ d[1] - 1 ].push_back(d[0] - 1);\n        }\n        colors_ = vector<int>(n,0); //0:unknown; 1: red. -1:blue\n        for(int i=0; i<n; i++) {\n            if(colors_[i]==0 && !dfs(i, 1))\n                return false;\n        }\n        return true;\n    }\n    bool dfs(int cur, int color) {\n        colors_[cur] = color;\n        for(int nxt: adj_[cur]) {\n            if(colors_[nxt] == color) \n                return false;\n            if(colors_[nxt] == 0 && !dfs(nxt, -color))\n                return false;\n        }\n        return true;\n    }\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<vector<int>> adj(n);\n        for(auto d:dislikes) {\n            adj[ d[0] - 1 ].push_back(d[1] - 1);\n            adj[ d[1] - 1 ].push_back(d[0] - 1);\n        }     \n        queue<int> q;\n        vector<int> colors(n,0); //0:unknown; 1: red. -1:blue\n        for(int i=0; i<n; i++) {\n            if(colors[i]!=0)\n                continue;\n            q.push(i);\n            colors[i] = 1;\n            while(!q.empty()) {\n                int cur = q.front();\n                q.pop();\n                for(int nxt: adj[cur]) {\n                    if(colors[nxt] == colors[cur]) \n                        return false;\n                    if(colors[nxt] != 0)\n                        continue;\n                    colors[nxt] = -colors[cur];\n                    q.push(nxt);\n                }\n            }\n        }\n        return true;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"possible-bipartition","has_notes":false,"flag_type":1}