{"id":1408711606,"question_id":235,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1727820806,"status":10,"status_display":"Accepted","runtime":"25 ms","url":"/submissions/detail/1408711606/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Search Tree","memory":"22 MB","code":"/*\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has \nboth p and q as descendants (where we allow a node to be a descendant of itself).”\nConstraints:\n\nThe number of nodes in the tree is in the range [2, 105].\n-109 <= Node.val <= 109\nAll Node.val are unique.\np != q\np and q will exist in the BST.\n*/\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //left is smaller.\n        if(p == NULL) \n            return NULL;\n        if(q==NULL)\n            return NULL;\n            //p, q not NULL\n        if(p == root || q == root )\n            return root;\n\n        if( p->val > q->val)\n            return lowestCommonAncestor(root, q, p);\n\n        if( (p->val < root->val) && (root->val < q->val) )\n            return root;\n        else if((p->val < root->val) && (q->val < root->val))\n            return lowestCommonAncestor(root->left, p, q); \n        else if((p->val > root->val) && (q->val > root->val))  \n            return lowestCommonAncestor(root->right, p, q);    \n        \n        return NULL;\n    }\n};","compare_result":"111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-search-tree","has_notes":false,"flag_type":1}