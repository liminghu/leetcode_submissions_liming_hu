{"id":1350308884,"question_id":1037,"lang":"cpp","lang_name":"C++","time":"6Â months","timestamp":1723229524,"status":10,"status_display":"Accepted","runtime":"83 ms","url":"/submissions/detail/1350308884/","is_pending":"Not Pending","title":"Minimum Number of K Consecutive Bit Flips","memory":"110.8 MB","code":"/*\nYou are given a binary array nums and an integer k.\nA k-bit flip is choosing a subarray of length k from nums and simultaneously changing \nevery 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum number of k-bit flips required so that there is no 0 in the array. \nIf it is not possible, return -1.\nA subarray is a contiguous part of an array.\n*/\nclass Solution {\npublic:\n    int minKBitFlips(vector<int>& nums, int k) {\n        //1 <= nums.length <= 105\n        //1 <= k <= nums.length\n        int sz = nums.size();\n        int res = 0;\n        queue<int> q;\n        for(int i=0; i<sz; i++) {\n            while(!q.empty() && i>q.front()+k-1)\n                q.pop();\n            if((nums[i] + q.size()) %2 == 0) { //q.size(): num of flips related to nums[i]. (nums[i] + q.size()) %2: current value of nums[i] after flips before i.\n                if(i+k > sz)\n                    return -1;\n                res++;\n                q.push(i);\n            }\n        }\n        return res;\n\n\n\n\n\n/*        int sz = nums.size();\n        int res = 0;\n        for(int i=0; i<sz; i++) {\n            if(nums[i]==0 && i>=sz-k+1)\n                return -1;\n            if(nums[i] == 0) {\n                nums[i] = 1;\n                //i+1   i+k-1\n                for(int j=i+1; j<=i+k-1; j++) {\n                    nums[j] = 1 - nums[j]; \n                }\n                res++;\n            } \n        }\n\n        return res;*/\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-number-of-k-consecutive-bit-flips","has_notes":false,"flag_type":1}