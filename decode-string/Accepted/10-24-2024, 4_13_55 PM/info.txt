{"id":1432891296,"question_id":394,"lang":"cpp","lang_name":"C++","time":"3 months, 2 weeks","timestamp":1729811635,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1432891296/","is_pending":"Not Pending","title":"Decode String","memory":"8.2 MB","code":"/*\nGiven an encoded string, return its decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets \nis being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; there are no extra white spaces, square \nbrackets are well-formed, etc. Furthermore, you may assume that the original data does not \ncontain any digits and that digits are only for those repeat numbers, k. For example, there \nwill not be input like 3a or 2[4].\nThe test cases are generated so that the length of the output will never exceed 105.\n1 <= s.length <= 30\ns consists of lowercase English letters, digits, and square brackets '[]'.\ns is guaranteed to be a valid input.\nAll the integers in s are in the range [1, 300].\n*/\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> countStack;\n        stack<string> stringStack;\n        string current;\n        int k = 0;\n        for( auto ch : s ) {\n            if(isdigit(ch)) {\n                k = k * 10 + ch - '0';\n            } else if( ch == '[') {\n                countStack.push(k); //push the number k to countStack;\n                stringStack.push(current); //push the current string to stringStack.\n                current = \"\"; //reset the current str.\n                k = 0; //reset count.\n            } else if ( ch == ']' ) {\n                string decodedString = stringStack.top();\n                stringStack.pop();\n                for(int k=countStack.top(); k>0; k--) { //decode k[current]\n                    decodedString += current;\n                }\n                countStack.pop();\n                current = decodedString;\n            } else {\n                current = current + ch;\n            }\n        }\n        return current;\n            \n /*       int index = 0;\n        return decodeString(s, index);\n    }\n    string decodeString(const string& s, int& index) {\n        string result;\n        while(index <s.length() && s[index]!= ']') {\n            if(!isdigit(s[index])) {\n                result += s[index];\n                index++;\n            } else {\n                int k=0;\n                while(index<s.length() && isdigit(s[index])) {\n                    k = k*10 + s[index]-'0';\n                    index++;\n                }\n                index++; //ignore opening square bracket '['\n                string decodedString = decodeString(s, index);\n                index++; //ignore the closing bracket ']';\n                while(k>0) {\n                    result += decodedString;\n                    k--;\n                }\n            }\n        }\n        return result;*/\n    }\n\n};","compare_result":"1111111111111111111111111111111111","title_slug":"decode-string","has_notes":false,"flag_type":1}