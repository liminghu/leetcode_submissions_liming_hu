{"id":1362724746,"question_id":146,"lang":"cpp","lang_name":"C++","time":"5 months, 2 weeks","timestamp":1724177707,"status":10,"status_display":"Accepted","runtime":"337 ms","url":"/submissions/detail/1362724746/","is_pending":"Not Pending","title":"LRU Cache","memory":"170.1 MB","code":"class LRUCache {\nprivate:\n    int cap_;\n    list<pair<int,int>> cache_; //key, value\n    unordered_map<int, list<pair<int,int>>::iterator> mp_;\npublic:\n    LRUCache(int capacity) {\n        cap_ = capacity;\n    }\n    \n    int get(int key) {\n        auto it = mp_.find(key);\n        if( it == mp_.end() )\n            return -1;\n        \n        cache_.splice(cache_.begin(), cache_, it->second);\n        return it->second->second; //value.\n        \n    }\n    \n    void put(int key, int value) {\n        auto it = mp_.find(key);\n        if(it != mp_.end()) {\n            it->second->second = value;\n            cache_.splice(cache_.begin(), cache_, it->second);\n            return;\n        }\n        if(cache_.size() == cap_) {\n            auto node = cache_.back();\n            mp_.erase(node.first); //key\n            cache_.pop_back();\n        }\n        cache_.push_front({key, value});\n        mp_[key] = cache_.begin();\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */","compare_result":"11111111111111111111111","title_slug":"lru-cache","has_notes":false,"flag_type":1}