{"id":401496776,"question_id":146,"lang":"cpp","lang_name":"C++","time":"4 years, 4 months","timestamp":1601235146,"status":10,"status_display":"Accepted","runtime":"136 ms","url":"/submissions/detail/401496776/","is_pending":"Not Pending","title":"LRU Cache","memory":"40.3 MB","code":"\nclass LRUCache {\npublic:\n    LRUCache(int capacity) {\n        capacity_ = capacity;\n    }\n    \n    int get(int key) {\n\t\tconst auto it = m_.find(key);\n\t\tif(it == m_.cend()) return -1;  //if key does not exist.\n\t\t//if it does exist, move the key to the front of the list.\n\t\tcache_.splice(cache_.begin(), cache_, it->second); //Transfers elements from x into the container, inserting them at position.\n\t\treturn it->second->second; //it->second: pointer to the value.\n    }\n\t\n    void put(int key, int value) {\n\t\tconst auto it = m_.find(key);\n\t\t//key already exists.\n\t\tif(it != m_.cend()) {\n\t\t\tit->second->second = value; //update value.\n\t\t    cache_.splice(cache_.begin(), cache_, it->second);\n\t\t\treturn;\n\t\t};\n\t\t\n\t\t//key does not exist.\n\t\t//reach the capacity? remove the oldest element.\n\t\tif(cache_.size() == capacity_) {\n\t\t\tconst auto& node = cache_.back();\n\t\t\tm_.erase(node.first);\n\t\t\tcache_.pop_back();\n\t\t}\n\t\tcache_.emplace_front(key, value);\n\t\tm_[key] = cache_.begin();\n        \n    }\nprivate:\n\tint capacity_;\n\tlist<pair<int, int>> cache_;\n\tunordered_map<int, list<pair<int,int>>::iterator> m_;\n\t\n};\n\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */","compare_result":"111111111111111111","title_slug":"lru-cache","has_notes":false,"flag_type":1}