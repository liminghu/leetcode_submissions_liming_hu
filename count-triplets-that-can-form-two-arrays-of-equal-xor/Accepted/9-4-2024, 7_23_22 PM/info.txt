{"id":1379430057,"question_id":1553,"lang":"cpp","lang_name":"C++","time":"5Â months","timestamp":1725503002,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1379430057/","is_pending":"Not Pending","title":"Count Triplets That Can Form Two Arrays of Equal XOR","memory":"10.2 MB","code":"/*\nGiven an array of integers arr.\nWe want to select three indices i, j and k where (0 <= i < j <= k < arr.length).\nLet's define a and b as follows:\na = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]\nb = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\nNote that ^ denotes the bitwise-xor operation.\nReturn the number of triplets (i, j and k) Where a == b.\n1 <= arr.length <= 300\n1 <= arr[i] <= 108\n*/\nclass Solution {\npublic:\n    int countTriplets(vector<int>& arr) {\n        unordered_map<int, vector<int>> mp; //pre_xor_sum_val -> {idx};\n        mp[0].push_back(-1);\n\n        int xorsum = 0;\n        int ret = 0;\n        for(int k=0; k<arr.size(); k++) {\n            xorsum ^= arr[k];\n            for(int i:mp[ xorsum ^ 0 ] ) {\n                //xor_sum: [i+1, k] == 0\n                 // j = i+2, ...k\n                 ret += k-i-1;\n            }\n            mp[xorsum].push_back(k);\n        }\n        return ret;\n\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111","title_slug":"count-triplets-that-can-form-two-arrays-of-equal-xor","has_notes":false,"flag_type":1}