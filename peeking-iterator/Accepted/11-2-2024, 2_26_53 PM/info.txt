{"id":1441140540,"question_id":284,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1730582813,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1441140540/","is_pending":"Not Pending","title":"Peeking Iterator","memory":"10.8 MB","code":"/*\n * Below is the interface for Iterator, which is already defined for you.\n * **DO NOT** modify the interface for Iterator.\n *\n *  class Iterator {\n *\t\tstruct Data;\n * \t\tData* data;\n *  public:\n *\t\tIterator(const vector<int>& nums);\n * \t\tIterator(const Iterator& iter); //Iterator has a copy constructor, we can just use it\n *\n * \t\t// Returns the next element in the iteration.\n *\t\tint next();\n *\n *\t\t// Returns true if the iteration has more elements.\n *\t\tbool hasNext() const;\n *\t};\n */\n\nclass PeekingIterator : public Iterator {\npublic:\n\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\n\t    // Initialize any member here.\n\t    // **DO NOT** save a copy of nums and manipulate it directly.\n\t    // You should only use the Iterator interface methods.\n\t    \n\t}\n\t\n    // Returns the next element in the iteration without advancing the iterator.\n\tint peek() {\n        return Iterator(*this).next(); //Iterator(*this) makes a copy of current iterator, then call next on the copied iterator to get the next value without affecting current iterator.\n\t}\n\t\n\t// hasNext() and next() should behave the same as in the Iterator interface.\n\t// Override them if needed.\n\tint next() {\n        return Iterator::next();\n\t}\n\t\n\tbool hasNext() const {\n\t    return Iterator::hasNext();\n\t}\n};","compare_result":"111111111111111","title_slug":"peeking-iterator","has_notes":false,"flag_type":1}