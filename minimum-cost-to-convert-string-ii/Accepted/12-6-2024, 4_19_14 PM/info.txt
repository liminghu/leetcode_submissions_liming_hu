{"id":1472228630,"question_id":3238,"lang":"cpp","lang_name":"C++","time":"2Â months","timestamp":1733530754,"status":10,"status_display":"Accepted","runtime":"993 ms","url":"/submissions/detail/1472228630/","is_pending":"Not Pending","title":"Minimum Cost to Convert String II","memory":"348.5 MB","code":"using LL = long long;\nclass TrieNode {\npublic:\n    TrieNode* next[26];\n    int idx;\n    TrieNode() {\n        for(int i=0; i<26; i++) \n            next[i] = NULL;\n        idx = -1;\n    }\n};\nclass Solution {\npublic:\n    TrieNode* root = new TrieNode();\n    long long minimumCost(string source, string target, vector<string>& original, vector<string>& changed, vector<int>& cost) {\n        // an integer array cost, where cost[i] represents the cost of converting the string original[i] to the string changed[i]\n        for(auto& s:original)\n            reverse(s.begin(), s.end());\n        for(auto& s:changed)\n            reverse(s.begin(), s.end()); \n        unordered_set<string> set;\n        set.insert(original.begin(), original.end());\n        set.insert(changed.begin(), changed.end());    \n        unordered_map<string,int> mp;\n        int idx = 0;\n        for(string word:set) {\n            mp[word] = idx;\n            TrieNode* node = root;\n            for(char c:word) {\n                if(node->next[c-'a'] == NULL)\n                   node->next[c-'a'] = new TrieNode();\n                node = node->next[c-'a']; \n            }\n            node->idx = idx;\n            idx++;\n        } \n        int n = set.size();\n        vector<vector<LL>> d(n, vector<LL>(n, LLONG_MAX/2));\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(i==j)\n                    d[i][j] = 0;\n            }\n        }\n        for(int i=0; i<original.size(); i++)\n            d[mp[original[i]]][mp[changed[i]]] = min(d[mp[original[i]]][mp[changed[i]]], (LL)cost[i]);\n        for(int k=0; k<n; k++) { //Floyd algorithm\n            for(int i=0; i<n; i++) {\n                for(int j=0; j<n; j++) \n                    d[i][j] = min(d[i][j], d[i][k]+d[k][j]);                \n            }\n        }    \n        int m = source.size();\n        source = \"$\" + source;\n        target = \"$\" + target;\n        vector<LL> dp(m+1);\n        dp[0] = 0;\n        for(int i=1; i<=m; i++) {\n            dp[i] = LLONG_MAX/2;\n            if(source[i]==target[i])\n                dp[i] = dp[i-1];\n            TrieNode* node1 = root;\n            TrieNode* node2 = root;\n            for(int j=i; j>=1; j--) {\n                if(node1->next[source[j]-'a']==NULL)\n                    break;\n                if(node2->next[target[j]-'a']==NULL)\n                    break;           \n                node1 = node1->next[source[j]-'a'];\n                node2 = node2->next[target[j]-'a'];\n                int idx1 = node1->idx;  \n                int idx2 = node2->idx;\n                if(idx1==-1 || idx2==-1)\n                    continue;\n                dp[i] = min(dp[i], dp[j-1]+d[idx1][idx2]);         \n            }\n        }     \n        return dp[m]==LLONG_MAX/2? -1: dp[m];\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-cost-to-convert-string-ii","has_notes":false,"flag_type":1}