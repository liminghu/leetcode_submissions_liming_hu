{"id":1512951060,"question_id":1485,"lang":"cpp","lang_name":"C++","time":"2 weeks, 5 days","timestamp":1737236301,"status":10,"status_display":"Accepted","runtime":"62 ms","url":"/submissions/detail/1512951060/","is_pending":"Not Pending","title":"Minimum Cost to Make at Least One Valid Path in a Grid","memory":"25.6 MB","code":"class Solution {\nvector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\npublic:\n    int minCost(vector<vector<int>>& grid) {\n        /*\n        1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n        2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n        3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n        4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n        */\n        int m = grid.size();\n        int n = grid[0].size();\n       int res  = m + n - 2;\n       vector<vector<int>> cost(m, vector<int>(n, m+n-2));\n       cost[0][0] = 0;\n       queue<pair<int, int>> q;\n       q.push({0, 0});      \n       while(!q.empty()) {\n            pair<int, int> t = q.front();\n            int i = t.first;\n            int j = t.second;\n            q.pop();\n            if(i==m-1 && j==n-1) {\n                res = min(res, cost[i][j]);\n            }\n            for(int k=0; k<4; k++) {\n                int new_i = i+dirs[k].first;\n                int new_j = j+dirs[k].second;\n                int curCost = grid[i][j]==k+1? cost[i][j]:(cost[i][j]+1);\n                if(new_i<0|| new_i>=m || new_j<0 || new_j>=n|| curCost>=cost[new_i][new_j] || curCost>=res)\n                    continue;\n                cost[new_i][new_j] = curCost;\n                q.push({new_i, new_j});\n            }\n       }\n       return res;  \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-cost-to-make-at-least-one-valid-path-in-a-grid","has_notes":false,"flag_type":1}