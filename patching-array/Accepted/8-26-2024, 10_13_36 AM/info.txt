{"id":1369210526,"question_id":330,"lang":"cpp","lang_name":"C++","time":"5 months, 2 weeks","timestamp":1724692416,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/1369210526/","is_pending":"Not Pending","title":"Patching Array","memory":"14.2 MB","code":"/*Given a sorted integer array nums and an integer n, add/patch elements to the array such \nthat any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.\nReturn the minimum number of patches required.\n*/\nclass Solution {\npublic:\n    int minPatches(vector<int>& nums, int n) {\n        /*  1 <= nums.length <= 1000\n            1 <= nums[i] <= 104\n            nums is sorted in ascending order.\n            1 <= n <= 231 - 1\n        */\n        long miss = 1; //Let miss be the smallest sum in [0,n] that we might be missing\n        int res = 0;\n        int sum = 0;\n        int i = 0;\n        /*Then if we have a number num <= miss in the given array, we can add it to those \n        smaller sums to build all sums in [0,miss+num). If we don't, then we must add such \n        a number to the array, and it's best to add miss itself, to maximize the reach.*/\n        while(miss <= n) {\n            if(i<nums.size() && nums[i] <=miss) {\n                miss+= nums[i];\n                i++;\n            } else {\n                miss += miss;\n                res++;\n            }\n        }\n        return res;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"patching-array","has_notes":false,"flag_type":1}