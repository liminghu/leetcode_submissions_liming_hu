{"id":1386760466,"question_id":3438,"lang":"cpp","lang_name":"C++","time":"4 months, 4 weeks","timestamp":1726072714,"status":10,"status_display":"Accepted","runtime":"876 ms","url":"/submissions/detail/1386760466/","is_pending":"Not Pending","title":"Peaks in Array","memory":"349.9 MB","code":"/*\nA peak in an array arr is an element that is greater than its previous and next element in arr.\nYou are given an integer array nums and a 2D integer array queries.\nYou have to process queries of two types:\nqueries[i] = [1, li, ri], determine the count of peak elements in the \nsubarray\n nums[li..ri].\nqueries[i] = [2, indexi, vali], change nums[indexi] to vali.\nReturn an array answer containing the results of the queries of the first type in order.\nNotes:\nThe first and the last element of an array or a subarray cannot be a peak.\n3 <= nums.length <= 105\n1 <= nums[i] <= 105\n1 <= queries.length <= 105\nqueries[i][0] == 1 or queries[i][0] == 2\nFor all i that:\nqueries[i][0] == 1: 0 <= queries[i][1] <= queries[i][2] <= nums.length - 1\nqueries[i][0] == 2: 0 <= queries[i][1] <= nums.length - 1, 1 <= queries[i][2] <= 105\n*/\nusing LL = long long;\nclass SegTreeNode\n{\n    public:\n    SegTreeNode* left = NULL;\n    SegTreeNode* right = NULL;\n    int start, end;\n    LL info;  // the sum value over the range\n    bool lazy_tag; \n    LL lazy_val;\n        \n    SegTreeNode(int a, int b, int val)  // init for range [a,b] with val\n    {                 \n        lazy_tag = 0;\n        lazy_val = 0;\n        start = a, end = b;\n        if (a==b)\n        {\n            info = val;\n            return;\n        }        \n        int mid = (a+b)/2;\n        if (left==NULL)\n        {\n            left = new SegTreeNode(a, mid, val);\n            right = new SegTreeNode(mid+1, b, val);            \n            info = left->info + right->info;  // check with your own logic\n        }        \n    }    \n    \n    SegTreeNode(int a, int b, vector<int>& val)  // init for range [a,b] with the same-size array val\n    {                 \n        lazy_tag = 0;\n        lazy_val = 0;\n        start = a, end = b;\n        if (a==b)\n        {\n            info = val[a];\n            return;\n        }        \n        int mid = (a+b)/2;\n        if (left==NULL)\n        {\n            left = new SegTreeNode(a, mid, val);\n            right = new SegTreeNode(mid+1, b, val);            \n            info = left->info + right->info;  // check with your own logic\n        }        \n    }    \n    \n    void pushDown()\n    {\n        if (lazy_tag==1 && left)\n        {\n            left->info = lazy_val * (left->end - left->start + 1);\n            right->info = lazy_val * (right->end - right->start + 1);\n            left->lazy_tag = 1; left->lazy_val = lazy_val;\n            right->lazy_tag = 1; right->lazy_val = lazy_val;\n            lazy_tag = 0;  lazy_val = 0;\n        }        \n    } \n    \n    void updateRange(int a, int b, int val)     // set range [a,b] with val\n    {        \n        if (b < start || a > end ) // not covered by [a,b] at all\n            return;        \n        if (a <= start && end <=b)  // completely covered within [a,b]\n        {\n            info = val * (end-start+1);\n            lazy_tag = 1;\n            lazy_val = val;\n            return;\n        }\n\n        if (left)\n        {\n            pushDown();        \n            left->updateRange(a, b, val);\n            right->updateRange(a, b, val);\n            info = left->info + right->info;  // write your own logic            \n        }        \n    }\n    \n    LL queryRange(int a, int b)     // query the sum over range [a,b]\n    {\n        if (b < start || a > end )\n        {\n            return 0;  // check with your own logic\n        }\n        if (a <= start && end <=b)\n        {\n            return info;  // check with your own logic\n        }          \n        \n        if (left)\n        {\n            pushDown();     \n            LL ret = left->queryRange(a, b) + right->queryRange(a, b);        \n            info = left->info + right->info;    // check with your own logic\n            return ret;\n        }\n        \n        return info;   // should not reach here\n    }  \n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int>peaks(n, 0);\n        for (int i=1; i<n-1; i++) { //exclude left, right.\n            if (nums[i]>nums[i-1] && nums[i]>nums[i+1])\n                peaks[i] = 1;\n        }\n        \n        SegTreeNode* root = new SegTreeNode(0, n-1, peaks); \n        \n        vector<int> rets;\n        for (auto query: queries) {\n            if (query[0] == 1 ) { //queries[i] = [1, li, ri], determine the count of peak elements in the subarray nums[li..ri].\n                int a = query[1], b = query[2];                \n                rets.push_back(root->queryRange(a+1, b-1));                \n            } else { //queries[i] = [2, indexi, vali], change nums[indexi] to vali.\n                int indexi = query[1];\n                nums[indexi] = query[2];\n                if (indexi>=1 && indexi<n-1) \n                    check(root, indexi, nums, peaks);\n                if (indexi-1>=1 && indexi-1<n-1) \n                    check(root, indexi-1, nums, peaks);\n                if (indexi+1>=1 && indexi+1<n-1) \n                    check(root, indexi+1, nums, peaks);                \n            }                \n        }\n        \n        return rets;      \n    }\n\n    void check(SegTreeNode* root, int i, vector<int>& nums, vector<int>& peaks)\n    {\n        int v = nums[i]>nums[i-1] && nums[i]>nums[i+1];\n        if (v==peaks[i]) \n            return;\n        peaks[i] = v;\n        root->updateRange(i, i, v );\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"peaks-in-array","has_notes":false,"flag_type":1}