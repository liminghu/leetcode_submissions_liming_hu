{"id":1524893911,"question_id":2583,"lang":"cpp","lang_name":"C++","time":"1 week, 1 day","timestamp":1738198714,"status":10,"status_display":"Accepted","runtime":"121 ms","url":"/submissions/detail/1524893911/","is_pending":"Not Pending","title":"Divide Nodes Into the Maximum Number of Groups","memory":"41.5 MB","code":"class Solution {\n    vector<int> adj[501]; //adjacent graph\n    int col[501];\n    int dist[501][501];\n    bool flag = false;\n    //nodes in a connected graph\n    vector<int> connectedNodes;\npublic:\n    int magnificentSets(int n, vector<vector<int>>& edges) {\n        //edges[i] = [ai, bi]\n        /*Divide the nodes of the graph into m groups (1-indexed) such that:\n        Each node in the graph belongs to exactly one group.\n        For every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1.\n        */\n        //Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.\n        //no cycle of odd nodes.\n        for(auto& edge:edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        };\n        for(int src=1; src<=n; src++)\n            bfs(src); ////calculate minimum distance between all nodes, start from src\n        int ans = 0;\n        int in = 0;\n        for(int i=1; i<=n; i++) {\n            if(col[i] == 0) {\n               connectedNodes.clear();\n               flag = true;\n               in++;\n               dfs(i);\n               if(!flag)\n                return -1;\n                int mxdist = 0;\n                for(int i: connectedNodes) {\n                    for(int j:connectedNodes) {\n                        mxdist = max(mxdist, dist[i][j]);\n                    }\n                } \n                ans+= mxdist;\n            }\n        }\n        return ans;\n\n    }\n    //calculate minimum distance between all nodes.\n    void bfs(int src) {\n        for(int i=1; i<=500; i++)\n            dist[src][i] = INT_MAX;\n        dist[src][src] = 1;\n        queue<int> q;\n        q.push(src);\n        while(!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            for(int next:adj[cur]) { //cur->next\n                if(dist[src][next]>dist[src][cur]+1) {\n                   dist[src][next]=dist[src][cur]+1;\n                   q.push(next); \n                } \n            }\n        };\n    }\n    //check if graph is bipartie\n    void dfs(int u, int c=1) {\n        col[u] = c;\n        connectedNodes.push_back(u);\n        for(int v: adj[u]) {\n            if(!col[v] )\n                dfs(v, 3-c);\n            else\n                if(col[v]==c)\n                    flag = 0; //graph is not bipartite.\n        }\n    }\n\n};","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"divide-nodes-into-the-maximum-number-of-groups","has_notes":false,"flag_type":1}