{"id":1308793654,"question_id":684,"lang":"cpp","lang_name":"C++","time":"7 months, 1 week","timestamp":1720050777,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1308793654/","is_pending":"Not Pending","title":"Redundant Connection","memory":"11.5 MB","code":"/*\nIn this problem, a tree is an undirected graph that is connected and has no cycles.\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one \nadditional edge added. The added edge has two different vertices chosen from 1 to n, and\n was not an edge that already existed. The graph is represented as an array edges of length \n n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. \nIf there are multiple answers, return the answer that occurs last in the input.\n*/\nclass UnionFindSet {\npublic:\n    UnionFindSet(int n) {\n        ranks_ = vector<int>(n + 1, 0);        \n        parents_ = vector<int>(n + 1, 0);                \n        \n        for (int i = 0; i < parents_.size(); ++i)  //n+1\n            parents_[i] = i; //parent is itself.\n    }\n    \n    // Merge sets that contains u and v.\n    // Return true if merged, false if u and v are already in one set.\n    bool Union(int u, int v) {\n        int pu = Find(u);\n        int pv = Find(v);\n        if (pu == pv) return false;\n        \n        // Meger low rank tree into high rank tree\n        if (ranks_[pv] > ranks_[pu])\n            parents_[pu] = pv;           \n        else if (ranks_[pu] > ranks_[pv])\n            parents_[pv] = pu;\n        else {\n            parents_[pv] = pu;\n            ranks_[pv] += 1;\n        }\n        \n        return true;\n    }\n    \n    // Get the root of u.\n    int Find(int u) {        \n        // Compress the path during traversal\n        if (u != parents_[u])\n            parents_[u] = Find(parents_[u]);        \n        return parents_[u];\n    }\nprivate:\n    vector<int> parents_;\n    vector<int> ranks_;\n};\n \nclass Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) { //n == edges.length\n                                                                    //3 <= n <= 1000\n                                                                    //edges[i].length == 2\n                                                                    //1 <= ai < bi <= edges.length\n                                                                    //ai != bi\n                                                                    //There are no repeated edges.\n                                                                    //The given graph is connected.      \n        UnionFindSet s(edges.size());\n        \n        for(const auto& edge: edges)\n            if (!s.Union(edge[0], edge[1]))  //if the two nodes can not be merged: they are already in one set.\n                return edge;\n        \n        return {};\n    }\n};","compare_result":"111111111111111111111111111111111111111","title_slug":"redundant-connection","has_notes":false,"flag_type":1}