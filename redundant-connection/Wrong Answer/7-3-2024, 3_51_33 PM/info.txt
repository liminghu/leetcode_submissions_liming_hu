{"id":1308770953,"question_id":684,"lang":"cpp","lang_name":"C++","time":"7 months, 1 week","timestamp":1720047093,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1308770953/","is_pending":"Not Pending","title":"Redundant Connection","memory":"N/A","code":"/*\nIn this problem, a tree is an undirected graph that is connected and has no cycles.\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one \nadditional edge added. The added edge has two different vertices chosen from 1 to n, and\n was not an edge that already existed. The graph is represented as an array edges of length \n n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. \nIf there are multiple answers, return the answer that occurs last in the input.\n*/\nclass Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) { //n == edges.length\n                                                                    //n == edges.length\n                                                                    //3 <= n <= 1000\n                                                                    //edges[i].length == 2\n                                                                    //1 <= ai < bi <= edges.length\n                                                                    //ai != bi\n                                                                    //There are no repeated edges.\n                                                                    //The given graph is connected.      \n        //find the loop and remove the last edge in the loop.\n        int sz = edges.size();\n        vector<int> ans;\n\n        unordered_set<int> s;\n        for(int i=0; i<sz; i++) {\n            int node_a = edges[i][0];\n            int node_b = edges[i][1];\n            if( s.find(node_a) != s.end() && s.find(node_b) != s.end() ) {\n                ans.push_back(node_a);\n                ans.push_back(node_b);\n            } else {\n                s.insert(node_a);\n                s.insert(node_b);\n            }\n        }  \n\n        vector<int> result;\n        if(ans.size()>=2) {\n            int node_b = ans.back();\n            ans.pop_back();\n            int node_a = ans.back();\n\n            result.push_back(node_a);\n            result.push_back(node_b);\n        }\n        return result;\n    }\n};","compare_result":"111111111111111111000110000000000010000","title_slug":"redundant-connection","has_notes":false,"flag_type":1}