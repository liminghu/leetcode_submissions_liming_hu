{"id":1339945374,"question_id":2135,"lang":"cpp","lang_name":"C++","time":"6 months, 1 week","timestamp":1722454383,"status":10,"status_display":"Accepted","runtime":"491 ms","url":"/submissions/detail/1339945374/","is_pending":"Not Pending","title":"Maximum Number of Ways to Partition an Array","memory":"268.7 MB","code":"/*\nYou are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions:\n\n1 <= pivot < n\nnums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]\nYou are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged.\n\nReturn the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.\n*/\n//https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/solutions/1498999/c-o-n/?envType=company&envId=google&favoriteSlug=google-thirty-days\nclass Solution {\npublic:\n    int waysToPartition(vector<int>& nums, int k) {\n        /*n == nums.length\n            2 <= n <= 105\n            -105 <= k, nums[i] <= 105\n        */\n               \n        int sz = nums.size();\n        vector<long long> prefix_sum(sz), suff_sum(sz);\n\n        //store prefix and suffix sum\n        prefix_sum[0] = nums[0]; suff_sum[sz-1] = nums[sz-1];\n        for(int i=1; i<sz; ++i) { \n            prefix_sum[i]     = prefix_sum[i-1] + nums[i]; \n            suff_sum[sz-1-i] = suff_sum[sz-i] + nums[sz-1-i];\n        } \n \n        long long ans = 0;\n        //Thus, we maintain two hash maps, left & right, which store the count of differences.\n        //left stores the count of difference for j < i && right stores for j >= i, where i is the index of element which we are changing to K.\n        unordered_map<long long,long long> left;\n        unordered_map<long long,long long> right; //key: prefix_sum - suff_sum\n        \n        //intially store the differences in the hashmap right\n        for(int i=0;i<sz-1; ++i) //1 <= pivot < n\n            right[prefix_sum[i] - suff_sum[i+1]]++;\n        \n        if(right.count(0)) \n            ans = right[0];\n\n        for(int i=0; i<sz; ++i) {\n        /*We can easily see, all values from pref[ j ] to pref[n-1] will also increase by d, and all values from suff[ j ] to suff[ 0 ], will also increase by d.\n        So, if we had the count of all indexes i, such that:\n        if i < j, then pref[ i ] - suff[ i + 1] = d, in original array i.e. without changing j's value\n\n        Because, suffix sum from 0 to j is increased by d.\n        Thus this difference will now become 0.\n        Hence, i will become a pivot point.\n        if i >= j, then pref [ i ] - suff[ i+1 ] = -d, in original array i.e. without changing j's value\n\n        Because, prefix sum from j to n-1 is increased by d.\n        Thus this difference will now become 0.\n        Hence, i will become a pivot point.       */    \n\n            //find the number of pivot indexes when nums[j] is changed to k\n            long long curr = 0, diff = k-nums[i];\n            if(left.count(diff)) \n                curr += left[diff];\n            if(right.count(-diff)) \n                curr += right[-diff];\n\n            //update answer\n            ans = max(ans, curr);\n            \n\n            //transfer the current element from right to left\n            if( i < sz-1 ) {\n                long long dd = prefix_sum[i] - suff_sum[i+1]; \n                left[dd]++; \n                right[dd]--;\n                if(right[dd] == 0) \n                    right.erase(dd);\n\n            }\n        }\n        return ans; \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-number-of-ways-to-partition-an-array","has_notes":false,"flag_type":1}