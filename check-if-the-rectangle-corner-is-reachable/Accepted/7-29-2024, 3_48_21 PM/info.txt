{"id":1337807825,"question_id":3478,"lang":"cpp","lang_name":"C++","time":"6 months, 1 week","timestamp":1722293301,"status":10,"status_display":"Accepted","runtime":"244 ms","url":"/submissions/detail/1337807825/","is_pending":"Not Pending","title":"Check if the Rectangle Corner Is Reachable","memory":"40.8 MB","code":"class Solution {\n    vector<int> p; //parent;                   //union-find\n    int find(int x) {\n        if( x != p[x] )\n            p[x] = find( p[x] );\n        return p[x];\n    }\npublic:\n    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {\n        /*\n        You are given two positive integers X and Y, and a 2D array circles, where circles[i] = [xi, yi, ri] denotes \n        a circle with center at (xi, yi) and radius ri.\n        There is a rectangle in the coordinate plane with its bottom left corner at the origin and top right corner at \n        the coordinate (X, Y). You need to check whether there is a path \n        from the bottom left corner to the top right corner such that the entire path lies inside the rectangle, \n        does not touch or lie inside any circle, \n        and touches the rectangle only at the two corners.\n        Return true if such a path exists, and false otherwise.\n        */\n        \n        /*\n            3 <= X, Y <= 109\n            1 <= circles.length <= 1000\n            circles[i].length == 3\n            1 <= xi, yi, ri <= 109\n        */\n        //initialize\n        for( int i = 0; i < circles.size(); i++ ) {\n            p.push_back(i);\n        };\n\n        for( int i = 0; i < circles.size(); i++ ) {\n            for( int j = i+1; j < circles.size(); j++ ) {\n                long long d =  circles[i][2] + circles[j][2];\n                long long dx = circles[i][0] - circles[j][0];\n                long long dy = circles[i][1] - circles[j][1];\n                if( d * d >= dx * dx + dy * dy ) { //overlap\n                    p[find(i)] = find(j); //merge grp i to j\n                }\n            }\n        };\n\n        unordered_map<int, vector<int>> h; // grp id ->(left_x, right_x, lower_y, upper_y);\n        for(int i=0; i<p.size(); i++) {\n            int j = find(i); //j is the parent of i\n            if( h.find(j) == h.end() )\n                h[j] = {INT_MAX, INT_MIN, INT_MAX, INT_MIN};\n            int left_x  = circles[i][0] - circles[i][2];\n            int right_x = circles[i][0] + circles[i][2];\n            int lower_y = circles[i][1] - circles[i][2];\n            int upper_y = circles[i][1] + circles[i][2];\n            h[j] = { min( h[j][0], left_x ), max( h[j][1], right_x ), min( h[j][2], lower_y ), max( h[j][3], upper_y ) };\n        }\n\n        for(auto& [k, v]: h) {\n            if( v[0] <= 0  && v[1] >= X ) //vertical line is included.\n                return false;        \n            if( v[2] <= 0  && v[3] >= Y ) //horizontal line is included.\n                return false;   \n            if( v[0] <= 0  && v[2] <= 0 ) //origin is included.\n                return false;\n            if( v[1] >= X  && v[3] >= Y ) //top_right is included.\n                return false;                                       \n        }\n        return true;\n\n    }\n    \n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"check-if-the-rectangle-corner-is-reachable","has_notes":false,"flag_type":1}