{"id":1371530523,"question_id":140,"lang":"cpp","lang_name":"C++","time":"5 months, 1 week","timestamp":1724873862,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1371530523/","is_pending":"Not Pending","title":"Word Break II","memory":"9.3 MB","code":"/*\nGiven a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence\n where each word is a valid dictionary word. Return all such possible sentences in any order.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n*/\nclass Solution {\n        class TrieNode {\n        public:\n            TrieNode* child[26];\n            bool isEnd;\n            TrieNode() {\n                for(int i=0; i<26; i++) \n                    child[i] = NULL;\n                isEnd = false;\n            }\n    };\n    TrieNode* root;\n    int memo[301];\n    vector<string> rets;\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        /*  1 <= s.length <= 20\n            1 <= wordDict.length <= 1000\n            1 <= wordDict[i].length <= 10\n            s and wordDict[i] consist of only lowercase English letters.\n            All the strings of wordDict are unique.\n            Input is generated in a way that the length of the answer doesn't exceed 105.\n        */\n        root = new TrieNode();\n        for(auto word: wordDict) {\n            TrieNode* node = root;\n            for(auto ch: word) {\n                if(node->child[ch-'a'] == NULL) \n                   node->child[ch-'a'] = new TrieNode(); \n                node = node->child[ch-'a'];\n            }\n            node->isEnd = true;\n        }\n        vector<string> words;\n        dfs(s, 0, words);\n        return rets;\n    }\n   bool dfs(string& s, int cur, vector<string>& words) {\n        if(memo[cur] == 1)\n            return false;\n\n        if(cur == s.size()) {\n            string temp;\n            for(auto word: words) \n                temp += word + \" \";\n            temp.pop_back(); //remove last \" \"\n            rets.push_back(temp);\n            return true;\n        }\n\n        TrieNode* node = root;\n        bool flag = false;\n        for(int i=cur; i<s.size(); i++) {\n            if(node->child[ s[i]-'a' ]  != NULL) {\n                node = node->child[ s[i]-'a' ];\n                if(node->isEnd) {\n                    \n                    words.push_back( s.substr(cur, i-cur+1) ); //found.\n                    \n                    if( dfs(s, i+1, words) )\n                        flag = true;\n\n                    words.pop_back(); //back track\n                }\n            } else\n                break;\n        }\n        if( flag == false )\n            memo[cur] = 1;\n        return flag;\n    }\n};","compare_result":"111111111111111111111111111","title_slug":"word-break-ii","has_notes":false,"flag_type":1}