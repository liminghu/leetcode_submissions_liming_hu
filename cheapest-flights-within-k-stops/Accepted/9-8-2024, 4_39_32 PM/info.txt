{"id":1383711408,"question_id":803,"lang":"cpp","lang_name":"C++","time":"5Â months","timestamp":1725838772,"status":10,"status_display":"Accepted","runtime":"11 ms","url":"/submissions/detail/1383711408/","is_pending":"Not Pending","title":"Cheapest Flights Within K Stops","memory":"16.3 MB","code":"/*\nThere are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that \nthere is a flight from city fromi to city toi with cost pricei.\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such \nroute, return -1.\n1 <= n <= 100\n0 <= flights.length <= (n * (n - 1) / 2)\nflights[i].length == 3\n0 <= fromi, toi < n\nfromi != toi\n1 <= pricei <= 104\nThere will not be any multiple flights between two cities.\n0 <= src, dst, k < n\nsrc != dst\n*/\nclass Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n\n        /*Bellman Ford's algorithm is used to find the shortest paths from the source node to \n        all other vertices in a weighted graph. It depends on the idea that the shortest path \n        contains at most N - 1 edges (where N is the number of nodes in the graph) because the \n        shortest path cannot have a cycle.\n        */\n        // Distance from source to all other nodes.\n        vector<int> total_price(n, INT_MAX);\n        total_price[src] = 0;\n\n        // Run only K+1 times since we want shortest distance in K hops.\n        for (int i = 0; i <= k; i++) {\n            // Create a copy of dist vector.\n            vector<int> temp(total_price);\n            for (auto& flight : flights) {\n                if (total_price[ flight[0] ] != INT_MAX) {\n                    temp[flight[1]] = min( temp[flight[1]], total_price[ flight[0] ] + flight[2] );\n                }\n            }\n            // Copy the temp vector into dist.\n            total_price = temp;\n        }\n        return total_price[dst] == INT_MAX ? -1 : total_price[dst];\n\n    //bfs\n    /*    vector<vector<pair<int, int>>> adj(n); //to, price.\n        for (auto& flight : flights)\n            adj[flight[0]].push_back( {flight[1], flight[2]} ); //from, {to, price}\n        \n        vector<int> total_price(n, INT_MAX); //from src to city i, the total_price.\n        queue<pair<int, int>> q; //to, price.\n        q.push({src, 0});\n        int stops = 0;\n\n        while (stops <= k && !q.empty()) {\n            int size = q.size();\n            // Iterate on current level.\n            for(int i=0; i<size; i++) { //cur layer.\n                auto [cur_city, cur_price] = q.front();\n                q.pop();\n                // Iterate over neighbors of popped node.\n                for (auto& [neighbour, price] : adj[cur_city]) {\n                    if (cur_price + price >= total_price[neighbour]) //this is too expensive.\n                        continue;\n                    total_price[neighbour] = cur_price + price;\n                    q.push( {neighbour, total_price[neighbour]} );\n                }\n            }\n            stops++; //got to next layer.\n        }\n        return total_price[dst] == INT_MAX ? -1 : total_price[dst]; */\n\n    //dijkstra\n/*        vector<vector<pair<int,int>>> adj(n); \n        for(int i=0; i<flights.size(); i++) {\n            int from_i  = flights[i][0];\n            int to_i    = flights[i][1];\n            int price_i = flights[i][2];\n            adj[ from_i ].push_back( { to_i, price_i } );\n        };\n        vector<int> stops(n, INT_MAX); //from src to city i, how many stops.\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq; //min\n        //price_from_src_city, city, number_of_stops_from_src_city\n        pq.push({0, src, 0});\n        while(!pq.empty()) {\n            auto t = pq.top();\n            pq.pop();\n            int cur_price = t[0];\n            int cur_city  = t[1];\n            int cur_steps = t[2];\n            //If cur_steps > stops[cur_city], then we already visited this node with fewer steps earlier, so ignore the current triplet and move on.\n            if(cur_steps > stops[cur_city] || cur_steps > k+1) //k+1 flights maximum.\n                continue;\n            stops[cur_city] = cur_steps;\n            if(cur_city == dst)\n                return cur_price;\n            for(auto [neighbor, price]: adj[cur_city]) {\n                pq.push({cur_price + price, neighbor, cur_steps+1});\n            }\n        }\n        return -1;\n*/\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111","title_slug":"cheapest-flights-within-k-stops","has_notes":false,"flag_type":1}