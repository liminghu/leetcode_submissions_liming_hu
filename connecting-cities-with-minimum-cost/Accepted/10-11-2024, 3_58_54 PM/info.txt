{"id":1419456888,"question_id":1100,"lang":"cpp","lang_name":"C++","time":"3 months, 4 weeks","timestamp":1728687534,"status":10,"status_display":"Accepted","runtime":"140 ms","url":"/submissions/detail/1419456888/","is_pending":"Not Pending","title":"Connecting Cities With Minimum Cost","memory":"61.9 MB","code":"/*\nThere are n cities labeled from 1 to n. You are given the integer n and an array connections where \nconnections[i] = [xi, yi, costi] indicates that the cost of connecting city xi and city yi \n(bidirectional connection) is costi.\nReturn the minimum cost to connect all the n cities such that there is at least one path between each pair of cities. \nIf it is impossible to connect all the n cities, return -1,\nThe cost is the sum of the connections' costs used.\n\nExample 1:\nInput: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]\nOutput: 6\nExplanation: Choosing any 2 edges will connect all cities so we choose the minimum 2.\n\nExample 2:\nInput: n = 4, connections = [[1,2,3],[3,4,4]]\nOutput: -1\nExplanation: There is no way to connect all cities even if all edges are used.\n \nConstraints:\n1 <= n <= 104\n1 <= connections.length <= 104\nconnections[i].length == 3\n1 <= xi, yi <= n\nxi != yi\n0 <= costi <= 105\n*/\n/*\nThere are n cities labeled from 1 to n. You are given the integer n and an array \nconnections where connections[i] = [xi, yi, costi] indicates that the cost of \nconnecting city xi and city yi (bidirectional connection) is costi.\nReturn the minimum cost to connect all the n cities such that there is at \nleast one path between each pair of cities. If it is impossible to connect \nall the n cities, return -1,\nThe cost is the sum of the connections' costs used.\n1 <= n <= 104\n1 <= connections.length <= 104\nconnections[i].length == 3\n1 <= xi, yi <= n\nxi != yi\n0 <= costi <= 105\n*/\ntypedef pair<int,int> PII;\nclass Solution {\npublic:\n    int minimumCost(int n, vector<vector<int>>& connections) { //connections[i] = [xi, yi, costi]\n        vector<vector<PII>> costs(n+1);\n        vector<bool> visited(n+1, false);\n\n        for(auto connection: connections) {\n            int xi = connection[0];\n            int yi = connection[1];\n            int costi = connection[2]; \n            costs[xi].push_back( {costi, yi} );\n            costs[yi].push_back( {costi, xi} );\n        };\n        \n        priority_queue<PII, vector<PII>, greater<PII>> pq;\n        pq.push({0, 1}); // the cost from 0 to 1 is 0.\n        int numVisited = 0;\n        int res = 0;\n        while(numVisited < n  && !pq.empty() ) {\n            int cost = pq.top().first;\n            int city = pq.top().second;\n            pq.pop();\n            if(visited[city])\n                continue;\n            visited[city] = true;\n            numVisited++;\n            res += cost;\n            for(auto& conn: costs[city]) {\n                cost = conn.first;\n                city = conn.second;\n                if(!visited[city] ) {\n                    pq.push({cost, city});\n                }\n            }\n        } \n        return numVisited == n? res : -1;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111","title_slug":"connecting-cities-with-minimum-cost","has_notes":false,"flag_type":1}