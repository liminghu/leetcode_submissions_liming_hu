{"id":1512122112,"question_id":971,"lang":"cpp","lang_name":"C++","time":"2 weeks, 6 days","timestamp":1737178117,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/1512122112/","is_pending":"Not Pending","title":"Shortest Bridge","memory":"23.4 MB","code":"class Solution {\npublic:\n    queue<pair<int,int>> q;\n    vector<pair<int, int>> dirs = {{0,1}, {0, -1}, {1, 0}, {-1, 0}};\n    int shortestBridge(vector<vector<int>>& grid) {//n x n binary matrix grid where 1 represents land and 0 represents water.\n        int n = grid.size();\n        int firstX = -1, firstY = -1;\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if( grid[i][j] == 1) {\n                    firstX = i;\n                    firstY = j;\n                    dfs(grid, firstX, firstY, n);\n                    q.push({firstX, firstY});\n                    break;\n                }\n            }\n            if(firstX != -1)\n                break;\n        }\n\n        return bfs(grid, n);\n    }\n    //Start from grid[first_x][first_y] and use depth-first search to find and set the values of all cells of the same island (island A) to 2.\n    void dfs(vector<vector<int>>& grid, int x, int y, int n) {\n        if(x<0 || y<0 || x>=n || y>=n || grid[x][y] == 0 || grid[x][y] == 2)\n            return;\n        grid[x][y] = 2; //visited.\n        q.push({x,y});\n        dfs(grid, x+1, y,   n);\n        dfs(grid, x-1, y,   n);\n        dfs(grid, x,   y+1, n);\n        dfs(grid, x,   y-1, n);\n    }\n    int bfs(vector<vector<int>>& grid, int n) {\n        int d = 0;\n        while(!q.empty()) {\n            int sz = q.size();\n            while(sz-->0) {\n                auto cur = q.front();\n                q.pop();\n                for(auto dir: dirs) {\n                    int newX = cur.first + dir.first;\n                    int newY = cur.second + dir.second;\n                    if(newX<0 || newX>=n || newY <0 || newY>=n || grid[newX][newY]==2)\n                        continue;\n                    if(grid[newX][newY] == 1)\n                        return d;\n                    else if (grid[newX][newY] == 0) {\n                        q.push({newX, newY}); \n                        grid[newX][newY] = 2; //visited..\n                    }\n                } \n            }\n            d++; // increasing each level by distance + 1\n        }\n        return d;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-bridge","has_notes":false,"flag_type":1}