{"id":1414018208,"question_id":1022,"lang":"cpp","lang_name":"C++","time":"4Â months","timestamp":1728240859,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1414018208/","is_pending":"Not Pending","title":"Unique Paths III","memory":"8.6 MB","code":"/*\nYou are given an m x n integer array grid where grid[i][j] could be:\n\n1 representing the starting square. There is exactly one starting square.\n2 representing the ending square. There is exactly one ending square.\n0 representing empty squares we can walk over.\n-1 representing obstacles that we cannot walk over.\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n\n \n\nExample 1:\n\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\nExample 2:\n\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\nExample 3:\n\n\nInput: grid = [[0,1],[2,0]]\nOutput: 0\nExplanation: There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n \n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 20\n1 <= m * n <= 20\n-1 <= grid[i][j] <= 2\nThere is exactly one starting cell and one ending cell.\n*/\nclass Solution {\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        int sx = -1; //start\n        int sy = -1;\n        int n = 1; //starting is 1.\n        for(int i=0; i<grid.size(); i++) {\n            for(int j=0; j<grid[0].size(); j++) {\n                if( grid[i][j] == 0 )\n                    n++;\n                else if(grid[i][j] == 1) { //starting\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        return dfs(grid, sx, sy, n);\n    }\n    int dfs(vector<vector<int>>& grid, int x, int y, int n) {\n        if(x<0 || x == grid[0].size() ||\n           y<0 || y == grid.size() || \n           grid[y][x] == -1 )\n            return 0;  //not reachable\n        if( grid[y][x] == 2 )\n            return n == 0;\n        \n        grid[y][x] = -1;\n        int paths = dfs(grid, x+1, y, n-1) +\n                    dfs(grid, x-1, y, n-1) +\n                    dfs(grid, x, y+1, n-1) +\n                    dfs(grid, x, y-1, n-1);\n        grid[y][x] = 0;   //backtracking...\n        return paths;\n    }\n};","compare_result":"111111111111111111111111111111111111111","title_slug":"unique-paths-iii","has_notes":false,"flag_type":1}