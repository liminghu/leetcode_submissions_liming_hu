{"id":1409900977,"question_id":1977,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1727912757,"status":10,"status_display":"Accepted","runtime":"275 ms","url":"/submissions/detail/1409900977/","is_pending":"Not Pending","title":"Minimum Interval to Include Each Query","memory":"116.6 MB","code":"/*\nYou are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval \nstarting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of \nintegers it contains, or more formally righti - lefti + 1.\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval\n i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\nReturn an array containing the answers to the queries.\n1 <= intervals.length <= 105\n1 <= queries.length <= 105\nintervals[i].length == 2\n1 <= lefti <= righti <= 107\n1 <= queries[j] <= 107\n*/\nclass Solution {\npublic:\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\n        //intervals[i] = [lefti, righti]  size: righti - lefti + 1.\n\n        //The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\n        vector< pair<int,int> > qs;\n        for(int i=0; i<queries.size(); i++)\n            qs.push_back( {queries[i], i} );  //we need to have index for the result.\n        sort(qs.begin(), qs.end()); //increasing. \n        sort(intervals.begin(), intervals.end()); //increasing left.\n        \n        int i = 0;\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq; //top min pair: duration, right.\n        vector<int> rets(queries.size(), -1);\n        for(auto query: qs) {\n            auto [time, idx] = query;\n            while( i < intervals.size() && intervals[i][0] <= time ) { //this interval is qualified on left: left_i <= q <= q[j]\n                pq.push( {intervals[i][1]-intervals[i][0]+1, intervals[i][1]} ); //duration_i, right_i\n                i++;\n            }\n\n            while(!pq.empty() && pq.top().second < time ) //this interval is not qualified for q: q > right.     the incoming queries will also not choose this interval, since q[j] > q > right. \n                pq.pop();\n            if( !pq.empty() )\n                rets[idx] = pq.top().first; //duration will be the min.\n        } \n        return rets;\n    }\n};","compare_result":"111111111111111111111111111111111111111111","title_slug":"minimum-interval-to-include-each-query","has_notes":false,"flag_type":1}