{"id":1466851399,"question_id":1309,"lang":"cpp","lang_name":"C++","time":"2 months, 1 week","timestamp":1733009092,"status":10,"status_display":"Accepted","runtime":"191 ms","url":"/submissions/detail/1466851399/","is_pending":"Not Pending","title":"Sort Items by Groups Respecting Dependencies","memory":"124.3 MB","code":"class Solution {\npublic:\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        int nextGroupId = m;\n        unordered_map<int, unordered_set<int>> groupItems;\n        for(int i=0; i<n; i++) {\n            if(group[i]==-1) {\n                group[i] = nextGroupId;\n                nextGroupId++;\n            }\n            groupItems[group[i]].insert(i);\n        }        \n        unordered_map<int, unordered_set<int>> next;\n        unordered_map<int,int> inDegree;\n        //build graph inside each grp.\n        for(int i=0; i<n; i++) {\n            for(int j:beforeItems[i]) {\n                //j->i\n                if(group[j]!=group[i])\n                    continue;\n                next[j].insert(i);\n                inDegree[i]++;\n            }\n        }\n\n        unordered_map<int, vector<int>> groupItemsOrdered;\n        for(auto x:groupItems) {\n            int groupId = x.first;\n            groupItemsOrdered[groupId] = topologySort(groupItems[groupId], next, inDegree);\n            if(groupItemsOrdered[groupId].size() != groupItems[groupId].size())\n                return {};\n        }\n\n        next.clear();\n        inDegree.clear();\n        //build graph among groups\n        for(int i=0; i<n; i++) {\n            for(int j:beforeItems[i]) {\n                if(group[i]==group[j])\n                    continue;\n                if(next[group[j]].find(group[i])==next[group[j]].end()) {\n                    next[group[j]].insert(group[i]);\n                    inDegree[group[i]]++;\n                }\n            }\n        }\n        unordered_set<int> groupIds;\n        for(int i=0; i<n; i++)\n            groupIds.insert(group[i]);\n        vector<int> groupsOrdered = topologySort(groupIds, next, inDegree);\n        vector<int> rets;\n        for(auto groupId:groupsOrdered) {\n            for(auto node: groupItemsOrdered[groupId])\n                rets.push_back(node);\n        }\n        return rets;\n    }\n    vector<int> topologySort(unordered_set<int>& nodes, unordered_map<int, unordered_set<int>>& next, unordered_map<int,int>& inDegree) {\n        queue<int> q;\n        for(int node:nodes) {\n            if(inDegree[node]==0)\n                q.push(node);\n        }\n        vector<int> ret;\n        while(!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            ret.push_back(cur);\n            for(auto nxt:next[cur]) {\n                inDegree[nxt]--;\n                if(inDegree[nxt] == 0)\n                    q.push(nxt);\n            }\n        }\n        if(ret.size() != nodes.size())\n            return {};\n        return ret;\n    }\n};","compare_result":"111111111111111111","title_slug":"sort-items-by-groups-respecting-dependencies","has_notes":false,"flag_type":1}