{"id":1401263054,"question_id":1474,"lang":"cpp","lang_name":"C++","time":"4 months, 2 weeks","timestamp":1727217948,"status":10,"status_display":"Accepted","runtime":"128 ms","url":"/submissions/detail/1401263054/","is_pending":"Not Pending","title":"Longest ZigZag Path in a Binary Tree","memory":"92.8 MB","code":"/*\nYou are given the root of a binary tree.\nA ZigZag path for a binary tree is defined as follow:\nChoose any node in the binary tree and a direction (right or left).\nIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\nChange the direction from right to left or from left to right.\nRepeat the second and third steps until you can't move in the tree.\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\n\nReturn the longest ZigZag path contained in that tree.\nThe number of nodes in the tree is in the range [1, 5 * 104].\n1 <= Node.val <= 100\n*/\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n//int pathLength = 0;\n    int longestZigZag(TreeNode* root) {\n        int res = 0;\n        helper(root, res);\n        return res;\n    /*    int l = 0;\n        int r = 0;\n        int ans = 0;\n        dfs(root, l, r, ans);\n        return ans;*/\n   /*     dfs(root, false, 0);\n        dfs(root, true, 0);\n        return pathLength;\n    }\n    void dfs(TreeNode* node, bool goLeft, int steps) {\n        if(node == NULL)\n            return;\n        pathLength = max(pathLength, steps);\n        if(goLeft) { // go left\n            dfs(node->left, false, steps+1); //go left, then right.\n            dfs(node->right, true, 1); // if we decide to go right, then next step must go left, and ignore parent steps.\n        } else { //go right.\n            dfs(node->right, true, steps+1); //go right, then left.\n            dfs(node->left, false, 1); // if we decide to go left, then next step must go right, and ignore parent steps.          \n        }*/\n    }\n\n    pair<int,int> helper(TreeNode* curr, int& res) {\n        if(curr == NULL)\n            return {-1, -1};\n        pair<int, int> left = helper(curr->left, res);\n        pair<int, int> right = helper(curr->right, res);\n        pair<int, int> curr_result = make_pair(left.second+1, right.first+1);\n        res = max(res, max(curr_result.first, curr_result.second));\n        return curr_result;\n    }\n\n/*\nParameters:\nl = count of max zigzag which reaches current Node by moving LEFT from par Node.\nr = count of max zigzag which reaches current Node by moving RIGHT from par Node.\nNow update ans upto current node\nthen send l+1 to RIGHT\nand r+1 to LEFT\n*/\n /*   void dfs(TreeNode* root, int l, int r, int& ans) {\n        if(!root)\n            return;\n        ans = max(ans, l);\n        ans = max(ans, r);\n        dfs(root->left, 0, l+1, ans);\n        dfs(root->right, r+1, 0, ans);\n        return;\n    }*/\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"longest-zigzag-path-in-a-binary-tree","has_notes":false,"flag_type":1}