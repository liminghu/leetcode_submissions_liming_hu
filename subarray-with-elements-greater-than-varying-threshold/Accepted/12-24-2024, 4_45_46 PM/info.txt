{"id":1487575457,"question_id":2419,"lang":"cpp","lang_name":"C++","time":"1 month, 2 weeks","timestamp":1735087546,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1487575457/","is_pending":"Not Pending","title":"Subarray With Elements Greater Than Varying Threshold","memory":"108.1 MB","code":"class Solution {\npublic:\n    int validSubarraySize(vector<int>& nums, int threshold) {//1 <= nums[i], threshold <= 109\n        //The gist of the above statement is that we need to find the subarray minimum and we need to expand that subarray as max as possible so as to have as less threshold / k as possible.\n        int n = nums.size();\n        vector<int> stk; //stack.\n        vector<int> nextS(n, -1); //next smaller element\n        vector<int> prevS(n, -1); //prev smaller element.\n        for(int i=0; i<n; i++) { //find the next smaller element.\n            while(!stk.empty() && nums[i] < nums[stk.back()]) {\n                nextS[stk.back()] = i;\n                stk.pop_back();\n            }\n            stk.push_back(i);\n        };\n        stk.clear();\n        for(int i=n-1; i>=0; i--) { //find the prev smaller element.\n            while(!stk.empty() && nums[i] < nums[stk.back()]) {\n                prevS[stk.back()] = i;\n                stk.pop_back();\n            }\n            stk.push_back(i);\n        };        \n       for(int i=0; i<n; i++) { \n            int left = prevS[i];\n            int right = nextS[i]==-1? n: nextS[i];\n            int len = right-left-1;     //len of subarray formed with a[i] as minimum.\n            if(nums[i]> threshold /(double)len) //it does not include left and right.\n                return len;\n       }        \n       return -1;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111","title_slug":"subarray-with-elements-greater-than-varying-threshold","has_notes":false,"flag_type":1}