{"id":1361580648,"question_id":2044,"lang":"cpp","lang_name":"C++","time":"5 months, 3 weeks","timestamp":1724086772,"status":10,"status_display":"Accepted","runtime":"44 ms","url":"/submissions/detail/1361580648/","is_pending":"Not Pending","title":"Number of Wonderful Substrings","memory":"16.5 MB","code":"/*A wonderful string is a string where at most one letter appears an odd number of times.\r\n\r\nFor example, \"ccjjc\" and \"abab\" are wonderful, but \"ab\" is not.\r\nGiven a string word that consists of the first ten lowercase English letters ('a' through 'j'), \r\nreturn the number of wonderful non-empty substrings in word. If the same substring appears multiple \r\ntimes in word, then count each occurrence separately.\r\n\r\nA substring is a contiguous sequence of characters in a string.\r\n*/\r\n\r\n/*First part: we only care about if a letter is odd or even count, so we can track the current state of the string from [0...i] \r\nusing a bitmask. 1 will mean that character is odd and 0 will mean that character is even. For example, \"1001\" means d has \r\nodd count, c even, b even, a odd\r\n\r\nTo calculate the answer: We go through from index 0 to the length of the string, updating the state of the string from [0...current index].\r\n If we have seen our current state before (say [0...j] has the same state as [0...i], that means the substring between j and i has \r\n an even count of all characters. Think about each new character as flicking it's own light switch. Flicking a switch an even amount \r\n of times results in no change. So if we see that we have previously run into the current state, we know there is a substring with \r\n even count of all characters in between that state and the current state. We add however many times we have previously run into the \r\n current state. This is because if we've run into the state once before, say at j, we know [j...current index] has even count of all \r\n characters. So we add 1 to our answer. If we've run into the state twice before, say at j and i, we know that [j... current index] \r\n has even count of all characters and [i...current index] has even count of all characters, so we add 2.\r\n\r\nNext we tackle the part where one character can be odd. If there is one character which occurs an odd amount of times between \r\n[previous index... current index], and all other characters are even, that means we only need to flick one switch to turn our \r\ncurrent state into the previous one. We try flicking each switch and see if we have run into that state before. If we have that \r\nmeans we have a wonderful substring because only 1 character appears an odd number of times between [previous index... current index]. \r\nAgain we add the number of times we have previously run into the state, because of the same reason as above. If we've seen the state at j, \r\nthen [j...current] has only 1 odd character, and if we've seen it at j and i, then [j...current] and [i...current] have only 1 odd character, etc.\r\n\r\nRuntime will be O(n)\r\n*/\r\nclass Solution {\r\npublic:\r\n    long long wonderfulSubstrings(string word) {\r\n        //1 <= word.length <= 105\r\n        //word consists of lowercase English letters from 'a' to 'j'.\r\n        int n = word.length();\r\n        int state = 0; //current state\r\n        vector<int> count(1<<10); //cnt[state] stores how many times the state occurs\r\n        count[0] = 1; //no letters, valid wonderful string. empty string gives case where all characters occur even number of times\r\n        long long ret = 0;\r\n        for(int i=0; i<n; i++) {\r\n            int k = word[i] - 'a';\r\n            state = state ^ (1<<k); // state[i], state is even.\r\n\r\n            ret += count[state]; //all letter freqs are even. add count of same previous states\r\n            for(int k = 0; k<10; k++) { //state is even.\r\n                int stateJ = state ^(1<<k);   //stateJ\r\n                ret += count[stateJ];\r\n            }\r\n            count[state] += 1;  //state[i], add 1 to count of times we've seen current state\r\n           \r\n        }\r\n        return ret;\r\n    }\r\n};\r\n\r\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-wonderful-substrings","has_notes":false,"flag_type":1}