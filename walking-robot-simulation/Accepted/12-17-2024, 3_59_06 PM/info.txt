{"id":1481539504,"question_id":906,"lang":"cpp","lang_name":"C++","time":"1 month, 3 weeks","timestamp":1734479946,"status":10,"status_display":"Accepted","runtime":"87 ms","url":"/submissions/detail/1481539504/","is_pending":"Not Pending","title":"Walking Robot Simulation","memory":"42.3 MB","code":"class Solution {\npublic:\n    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\n        /*  -2: Turn left 90 degrees.\n            -1: Turn right 90 degrees.\n            1 <= k <= 9: Move forward k units, one unit at a time.\n        */\n        // grid point obstacles[i] = (xi, yi)\n        /*  North means +Y direction.\n            East means +X direction.\n            South means -Y direction.\n            West means -X direction.\n        */\n        //   W\n        //S -|- N\n        //   E\n        vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //N(0), E(1), S(2), W(3)\n        unordered_set<string> objs;\n        for(auto obj:obstacles) {\n            objs.insert(to_string(obj[0]) + \"_\" + to_string(obj[1]));\n        } \n        int dir = 0; //N\n        int x = 0;\n        int y = 0;\n        int maxDistance = 0;\n        for(int i=0; i<commands.size(); i++) {\n            if(commands[i] == -2) //turn left\n                dir = (dir+3)%4;\n            else if(commands[i] == -1) //turn right.\n                dir = (dir+1)%4;\n            else {\n                int step = 0;\n                while( step<commands[i] && objs.find(to_string(x+dirs[dir][0])+\"_\"+to_string(y+dirs[dir][1]))==objs.end() ) {\n                    x += dirs[dir][0];\n                    y += dirs[dir][1];\n                    step++;\n                }\n            }\n            maxDistance = max(maxDistance, x*x+y*y);\n        }\n        return maxDistance;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"walking-robot-simulation","has_notes":false,"flag_type":1}