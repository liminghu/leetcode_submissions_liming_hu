{"id":1515200959,"question_id":2145,"lang":"cpp","lang_name":"C++","time":"2 weeks, 3 days","timestamp":1737422270,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1515200959/","is_pending":"Not Pending","title":"Grid Game","memory":"66.5 MB","code":"class Solution {\npublic:\n    long long gridGame(vector<vector<int>>& grid) {\n        int n = grid[0].size();\n        long long top = accumulate(grid[0].begin(), grid[0].end(), 0ll);\n        long long bottom = 0ll;\n        long long res = LLONG_MAX;\n        /*Since the robots cannot go up, we need to find the best point i for the first robot to go down.\n          For the second robot, we only have two choices - go down right away, or stay up till the end.\n          For a point i, the second robot can either collect bottom = sum(grid[1][0] .. grid[1][i - 1]) if it goes down, or top = sum(grid[0][i + 1] ... grid[0][n - 1]) otherwise.\n          We can compute those values using prefix/suffix sum in O(1), and then find the minimum of max(top, bottom).\n        */\n        for(int i=0; i<n; i++) { //suppose the first robot go down at i.\n            top -= grid[0][i];   //For a point i, the second robot can either collect bottom = sum(grid[1][0] .. grid[1][i - 1]), if the first robot goes down\n            res = min(res, max(top, bottom));\n            bottom += grid[1][i];\n        }\n        return res;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"grid-game","has_notes":false,"flag_type":1}