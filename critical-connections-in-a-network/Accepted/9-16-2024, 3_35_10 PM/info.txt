{"id":1392619147,"question_id":1300,"lang":"cpp","lang_name":"C++","time":"4 months, 3 weeks","timestamp":1726526110,"status":10,"status_display":"Accepted","runtime":"784 ms","url":"/submissions/detail/1392619147/","is_pending":"Not Pending","title":"Critical Connections in a Network","memory":"234.8 MB","code":"/*\nThere are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections \nforming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. \nAny server can reach other servers directly or indirectly through the network.\nA critical connection is a connection that, if removed, will make some servers unable to reach \nsome other server.\nReturn all critical connections in the network in any order.\n2 <= n <= 105\nn - 1 <= connections.length <= 105\n0 <= ai, bi <= n - 1\nai != bi\nThere are no repeated connections.\n*/\n/*Let's try and rephrase the problem a bit to see what it means in terms of the given graph. \nWe are given an undirected graph and are asked to find the number of bridges in the graph. \nA bridge is essentially an edge whose removal would make the graph disconnected.\n*/\nint MOD = 100001;\nusing LL = long long;\nclass Solution {\nprivate:\n    unordered_map<int, vector<int>> graph_; //adjacency list\n    unordered_map<int, int> rank_;\n    unordered_set<LL> connDict_;\n\n    int dfs(int node, int discoveryRank) {\n        // That means this node is already visited. We simply return the rank.\n        if ( rank_.find(node) != rank_.end() )\n            return rank_[node];\n        \n        //not visited. Update the rank of this node.\n        rank_[node] = discoveryRank;\n        \n        // This is the max we have seen till now. So we start with this instead of INT_MAX or something.\n        int minRank = discoveryRank + 1;\n        \n        for (auto neighbor : graph_[node]) {       //We iterate over all the neighbors of the node     \n            // Skip the parent.\n            if(rank_.find(neighbor) != rank_.end() && rank_[neighbor] == discoveryRank - 1)\n                continue;           \n            // Recurse on the neighbor.\n            int recursiveRank = dfs(neighbor, discoveryRank + 1);\n            \n            // Step 1, check if this edge needs to be discarded.\n            if (recursiveRank <= discoveryRank) {\n                int sortedU = min(node, neighbor); \n                int sortedV = max(node, neighbor);\n                LL key = LL(sortedU) * MOD + sortedV;\n                connDict_.erase(key);\n            }\n            \n            // Step 2, update the minRank if needed.\n            minRank = min(minRank, recursiveRank);\n        }\n        \n        return minRank;\n    } \n\npublic:\n    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {\n        //Tarjan's algorithm\n        //An edge is a critical connection, if and only if it is not in a cycle.\n        /*\n            the problem simply boils down to finding all the cycles in the graph and discarding\n            all the edges belonging to such cycles. If we do that, we will only be left with edges\n            that are critical connections in the graph.\n        */\n        for(auto edge : connections) {  //vector<int>          \n            // Bidirectional edges\n            int u = edge[0];\n            int v = edge[1];\n            graph_[u].push_back(v); //unordered_map<int, vector<int>> graph\n            graph_[v].push_back(u);\n            \n            int sortedU = min(u, v);\n            int sortedV = max(u, v);\n            LL key = (LL) sortedU * MOD + sortedV;\n            connDict_.insert( key ); //unordered_set<pair<int, int>> connDict\n        }\n        dfs(0, 0); //int node: 0, int discoveryRank: 0\n        \n        vector<vector<int>> result;\n        for (LL  criticalConnection : connDict_) {\n            int u = criticalConnection / (MOD);\n            int v = criticalConnection % (MOD);\n            result.push_back({u,v});\n        }\n        \n        return result;\n    } \n};            \n","compare_result":"11111111111111111","title_slug":"critical-connections-in-a-network","has_notes":false,"flag_type":1}