{"id":1326801375,"question_id":1207,"lang":"cpp","lang_name":"C++","time":"6 months, 3 weeks","timestamp":1721443724,"status":10,"status_display":"Accepted","runtime":"499 ms","url":"/submissions/detail/1326801375/","is_pending":"Not Pending","title":"Delete Nodes And Return Forest","memory":"191.7 MB","code":"/*Given the root of a binary tree, each node in the tree has a distinct value.\nAfter deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).\nReturn the roots of the trees in the remaining forest. You may return the result in any order.\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {\n        /* The number of nodes in the given tree is at most 1000.\n            Each node has a distinct value between 1 and 1000.\n            to_delete.length <= 1000\n            to_delete contains distinct values between 1 and 1000.\n        */\n        vector<TreeNode*> forest;\n        unordered_set<int> toDeleteSet(to_delete.begin(), to_delete.end());\n        root = delNodes_helper(root, toDeleteSet, forest);\n        if(root) \n            forest.push_back(root);\n\n        return forest;\n\n    }\n\n\n    TreeNode* delNodes_helper(TreeNode* &root, unordered_set<int> toDeleteSet, vector<TreeNode*>& forest) {\n        \n        if(root == nullptr) \n            return nullptr;\n        \n        root->left = delNodes_helper(root->left, toDeleteSet, forest); \n        root->right = delNodes_helper(root->right, toDeleteSet, forest);\n\n        if(toDeleteSet.find(root->val) !=toDeleteSet.end()) {\n            if(root->left)\n                forest.push_back(root->left);\n            if(root->right)\n                forest.push_back(root->right);    \n            delete root;\n            return nullptr;\n        }\n\n        return root;\n        \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"delete-nodes-and-return-forest","has_notes":false,"flag_type":1}