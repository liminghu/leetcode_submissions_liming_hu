{"id":1276826883,"question_id":759,"lang":"cpp","lang_name":"C++","time":"8 months, 1 week","timestamp":1717453167,"status":10,"status_display":"Accepted","runtime":"30 ms","url":"/submissions/detail/1276826883/","is_pending":"Not Pending","title":"Set Intersection Size At Least Two","memory":"21.1 MB","code":"class Solution {\npublic:\n/** \nTaking example of [[1,3],[1,4],[2,5],[3,5]]\n\n1) Sort them by end points, if end points match place bigger start point first use this example to understand why ([[1,3],[3,7],[5,7],[7,8]])\n[[1,3],[1,4],[3,5],[2,5]]\n2) Make an interval of first elements ending and ending - 1\n3) Traverse the array and total 3 cases can be there:\n    Case 1:\n        The starting point of current interval is less than our chosen interval's start (head)\n        Total overlap, move on\n    Case 2:\n        The starting point of current interval is less than our chosen interval's end (tail)\n        Half overlap, head becomes tail, tail becomes ending of current interval's end\n    Case 3:\n        The starting point of current interval is greater than our chosen interval's end\n        No overlap, we need to reset we again use same strategy of giving ending two points\n\n    Diagram:\n    0  1  2  3  4  5  6  7  8  9 10 11\n    |--|--|--|--|--|--|--|--|--|--|--|\n\n       |-----|\n       |--------|\n             |-----|\n          |--------|\n\t\t  \n\tInitial Interval\n          |--|\n\t   head  tail\n*/\n\n    int intersectionSizeTwo(vector<vector<int>>& intervals) { //Return the minimum possible size of a containing set.\n    //A containing set is an array nums where each interval from intervals has at least two integers in nums.\n        int ans=0;\n        sort(intervals.begin(), intervals.end(), [](auto &l, auto &r){\n            if(l[1]!=r[1])\n                return l[1] < r[1];\n            else \n                return l[0] > r[0];\n        }); //sort increasing, by ending, then start decreasing.\n\n        int count = 2;\n        int head = intervals[0][1]-1;\n        int tail = intervals[0][1]; //get the last 2 elements.\n\n        for(auto& interval:intervals) { //sorted tail increasing, then head decreasing.\n            if(interval[0] <=head) {      //Case 1:\n        //The starting point of current interval is less than our chosen interval's start (head)\n        //Total overlap, move on\n                continue;\n            } else if(interval[0] <=tail) {\n                // Case 2:\n        //The starting point of current interval is less than our chosen interval's end (tail)\n        //Half overlap, head becomes tail, tail becomes ending of current interval's end\n                head = tail;\n                tail = interval[1];\n                count++;\n            } else {\n                //Case 3:\n        //The starting point of current interval is greater than our chosen interval's end\n        //No overlap, we need to reset we again use same strategy of giving ending two points\n                head = interval[1]-1;\n                tail = interval[1];\n                count +=2;\n            }\n        }\n\n\n    return count;\n        \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"set-intersection-size-at-least-two","has_notes":false,"flag_type":1}