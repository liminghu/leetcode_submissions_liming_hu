{"id":1357046741,"question_id":465,"lang":"cpp","lang_name":"C++","time":"5 months, 3 weeks","timestamp":1723754413,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1357046741/","is_pending":"Not Pending","title":"Optimal Account Balancing","memory":"8.7 MB","code":"/*You are given an array of transactions transactions where transactions[i] = [fromi, toi, amounti] \nindicates that the person with ID = fromi gave amounti $ to the person with ID = toi.\nReturn the minimum number of transactions required to settle the debt.\n*/\nclass Solution {\nprivate:\n    int dfs(int idx, vector<int>& balance) {\n        if(idx == balance.size())\n            return 0; //no transaction needed.\n        int cur = balance[idx];\n        if(cur == 0)  //no transaction needed for current idx.\n            return dfs(idx+1, balance);\n        \n        int min_transactions = INT_MAX;\n\n        for(int i=idx+1; i<balance.size(); i++) {\n            int next = balance[i];\n            if(cur*next < 0) { //one is \"should be paid\" (+), the other is \"should pay.\" (-)\n                balance[i] = next + cur; //should be paid (+)\n                balance[idx] = 0; //it does not matter.\n                min_transactions = min(min_transactions, 1+dfs(idx+1, balance));\n                balance[idx] = cur;\n                balance[i] = next;\n\n                if(next + cur == 0)\n                    break;\n            }\n        }\n        return min_transactions;\n    }\npublic:\n    int minTransfers(vector<vector<int>>& transactions) {\n        //transactions[i] = [fromi, toi, amounti]\n        /*\n            1 <= transactions.length <= 8\n            transactions[i].length == 3\n            0 <= fromi, toi < 12\n            fromi != toi\n            1 <= amounti <= 100\n        */\n        unordered_map<int, int> mp; //account, balance.\n        for(int i=0; i<transactions.size(); i++) {\n            mp[transactions[i][0]] += transactions[i][2]; //should be paid.\n            mp[transactions[i][1]] -= transactions[i][2]; //should pay.\n        }\n\n        vector<int> balance;\n        for(auto iter: mp) {\n            if(iter.second != 0 ) {\n                balance.push_back(iter.second);\n            }\n        }\n        return dfs(0, balance);\n    }\n};","compare_result":"111111111111111111111111111111111111","title_slug":"optimal-account-balancing","has_notes":false,"flag_type":1}