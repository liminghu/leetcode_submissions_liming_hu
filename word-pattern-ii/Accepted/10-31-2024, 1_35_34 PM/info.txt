{"id":1439341554,"question_id":291,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1730406934,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1439341554/","is_pending":"Not Pending","title":"Word Pattern II","memory":"9.9 MB","code":"class Solution {\npublic:\n    bool wordPatternMatch(string pattern, string s) {\n        //A string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s\n        unordered_map<char, string> mp;\n        unordered_map<string, char> re_mp;\n        return dfs(pattern, 0, s, 0, mp, re_mp);\n    }\n    bool dfs(string pattern, int pp, string s, int ps, unordered_map<char, string>& mp, unordered_map<string, char>& re_mp) {\n        if(pp == pattern.size()) \n            return ps == s.size();\n        if(mp.find(pattern[pp]) != mp.end() ) {\n            string match = mp[pattern[pp]];\n            if( ps + match.size() > s.size() )\n                return false;\n            if( s.substr(ps, match.size() ) == match ) {\n                return dfs(pattern, pp+1, s, ps+match.size(), mp, re_mp);\n            } else\n                return false;\n        } else {\n            for(int j=ps; j<s.size(); j++) {\n                string match = s.substr(ps, j-ps+1);\n                if(re_mp.find(match) != re_mp.end())\n                    continue;  //been match by other char before.\n                mp[pattern[pp]] = match;\n                re_mp[match] = pattern[pp];\n                if(dfs(pattern, pp+1, s, ps+match.size(), mp, re_mp))\n                    return true;\n                //backtracking\n                mp.erase(pattern[pp]);\n                re_mp.erase(match);\n            }\n        }\n        \n        return false;\n    }\n};","compare_result":"11111111111111111111","title_slug":"word-pattern-ii","has_notes":false,"flag_type":1}