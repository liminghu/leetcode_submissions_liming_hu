{"id":1412044683,"question_id":126,"lang":"cpp","lang_name":"C++","time":"4Â months","timestamp":1728083368,"status":10,"status_display":"Accepted","runtime":"37 ms","url":"/submissions/detail/1412044683/","is_pending":"Not Pending","title":"Word Ladder II","memory":"19.2 MB","code":"/*\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty \nlist if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\n\nExample 1:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\nExplanation: There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\n\nExample 2:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: []\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n \n\nConstraints:\n1 <= beginWord.length <= 5\nendWord.length == beginWord.length\n1 <= wordList.length <= 500\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.\nThe sum of all shortest transformation sequences does not exceed 105.\n*/\nclass Solution {\npublic:\n    unordered_set<string> wordSet;\n    unordered_map<string, vector<string>> next;\n    unordered_map<string, vector<string>> prev;\n    string beginWord;\n    vector<vector<string>> res;\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        wordSet.insert(beginWord);\n        for(auto word: wordList) //put all the words in the dict.\n            wordSet.insert(word);\n        this->beginWord = beginWord;\n        if(wordSet.find(endWord) == wordSet.end()) //endWord not found.\n            return {};\n        \n        //build graph for next.\n        for(auto str: wordSet) {\n            for(int k=0; k<str.length(); k++) {\n                for(char ch='a'; ch<='z'; ch++) {\n                    string temp = str;\n                    temp[k] = ch;\n                    if(temp == str)\n                        continue;\n                    if( wordSet.find(temp) != wordSet.end() ) \n                        next[str].push_back(temp);\n                }\n            }\n        };\n\n        unordered_set<string> visited;\n        queue<string> q;\n        int found = 0;\n        q.push(beginWord);\n        visited.insert(beginWord);\n        while(!q.empty() ) {  //BFS to build prev\n            int size = q.size();\n            unordered_set<string> newVisited;\n            for(int k=0; k<size; k++) {\n                string str = q.front();\n                q.pop();\n                for(auto nextStr: next[str]) {\n                    if(visited.find(nextStr) != visited.end()) //nextStr has been visited before.\n                        continue;\n                    prev[nextStr].push_back(str);\n                    newVisited.insert(nextStr);  //has to be set, duplicates possible.\n                    if( nextStr == endWord ) {\n                        found = 1;\n                        break;\n                    }\n                }\n            }\n            for(auto item: newVisited) {\n                visited.insert(item);\n                q.push(item);\n            }\n        }\n\n        if( found == 0 )\n            return {};\n        \n        DFS(endWord, {endWord});\n        return res;\n    }\n\n    void DFS(string word, vector<string> path) {\n        if(word == beginWord) {\n            reverse(path.begin(), path.end());\n            res.push_back(path);\n            return;\n        }\n\n        for(auto preStr: prev[word]) {\n            vector<string> newPath = path;\n            newPath.push_back(preStr);\n            DFS(preStr, newPath);\n        }\n        return;\n    }\n};","compare_result":"111111111111111111111111111111111111","title_slug":"word-ladder-ii","has_notes":false,"flag_type":1}