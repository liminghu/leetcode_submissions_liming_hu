{"id":1350446869,"question_id":1790,"lang":"cpp","lang_name":"C++","time":"6Â months","timestamp":1723242701,"status":10,"status_display":"Accepted","runtime":"9 ms","url":"/submissions/detail/1350446869/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Tree III","memory":"14.2 MB","code":"/*Given two nodes of a binary tree p and q, return their lowest common ancestor (LCA).\n\nEach node will have a reference to its parent node. The definition for Node is below:\n\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}\nAccording to the definition of LCA on Wikipedia: \"The lowest common ancestor of two nodes p and q in a \ntree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself).\"\n*/\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* parent;\n};\n*/\n\nclass Solution {\npublic:\n    Node* lowestCommonAncestor(Node* p, Node * q) {\n        /*The number of nodes in the tree is in the range [2, 105].\n            -109 <= Node.val <= 109\n            All Node.val are unique.\n            p != q\n            p and q exist in the tree.*/\n        \n        vector<Node*> path_p;\n        Node* cur = p;\n        while(cur) {\n            path_p.push_back(cur);\n            cur = cur->parent;\n        };\n\n        vector<Node*> path_q;\n        cur = q;\n        while(cur) {\n            path_q.push_back(cur);\n            cur = cur->parent;\n        };\n\n        long i=path_p.size()-1;\n        long j=path_q.size()-1;\n        for(; i>=0 && j>=0; i--, j--) {\n            if(path_p[i] != path_q[j])\n                break;\n        };\n\n        return path_p[i+1];\n    }\n};","compare_result":"1111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-tree-iii","has_notes":false,"flag_type":1}