{"id":1445112744,"question_id":333,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1730921464,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1445112744/","is_pending":"Not Pending","title":"Largest BST Subtree","memory":"20.8 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass nodeProp {\npublic:\n    int minValue; //The minimum value in the subtree\n    int maxValue; //The maximum value in the subtree\n    int maxSize;  //max Size of the BST subtree.\n    nodeProp(int minValue, int maxValue, int maxSize) {\n        this->minValue = minValue;\n        this->maxValue = maxValue;\n        this->maxSize = maxSize;\n    }\n};\nclass Solution {\npublic:\n    int largestBSTSubtree(TreeNode* root) {\n        return helper(root).maxSize;\n    }\n    //By traversing each tree's children first, we can pass information about subtrees up to the parent. This information can be used by the parent to determine if the parent node is a BST in constant time.\n    nodeProp helper(TreeNode* root) { //postorder\n        if(root == NULL) { //// An empty tree is a BST of size 0.\n            return nodeProp(INT_MAX, INT_MIN, 0);\n        };\n        // Get values from left and right subtree of current tree.\n        nodeProp leftProp = helper(root->left);\n        nodeProp rightProp = helper(root->right);\n        if(leftProp.maxValue < root->val && root->val < rightProp.minValue) { //// Current node is greater than max in left AND smaller than min in right, it is a BST.\n            return nodeProp(min(root->val, leftProp.minValue), \n                            max(root->val, rightProp.maxValue),\n                            leftProp.maxSize + rightProp.maxSize + 1 );            \n        }\n\n        return nodeProp(INT_MIN, INT_MAX,\n                        max(leftProp.maxSize, rightProp.maxSize));            \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"largest-bst-subtree","has_notes":false,"flag_type":1}