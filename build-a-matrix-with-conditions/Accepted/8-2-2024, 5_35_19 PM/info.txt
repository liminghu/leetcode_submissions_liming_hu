{"id":1342391062,"question_id":2472,"lang":"cpp","lang_name":"C++","time":"6 months, 1 week","timestamp":1722645319,"status":10,"status_display":"Accepted","runtime":"95 ms","url":"/submissions/detail/1342391062/","is_pending":"Not Pending","title":"Build a Matrix With Conditions","memory":"60.6 MB","code":"/*\nYou are given a positive integer k. You are also given:\n\na 2D integer array rowConditions of size n where rowConditions[i] = [abovei, belowi], and\na 2D integer array colConditions of size m where colConditions[i] = [lefti, righti].\nThe two arrays contain integers from 1 to k.\n\nYou have to build a k x k matrix that contains each of the numbers from 1 to k exactly once. The remaining cells should have the value 0.\n\nThe matrix should also satisfy the following conditions:\n\nThe number abovei should appear in a row that is strictly above the row at which the number belowi appears for all i from 0 to n - 1.\nThe number lefti should appear in a column that is strictly left of the column at which the number righti appears for all i from 0 to m - 1.\nReturn any matrix that satisfies the conditions. If no answer exists, return an empty matrix.\n\n */\nclass Solution {\npublic:\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\n        /*  2 <= k <= 400\n            1 <= rowConditions.length, colConditions.length <= 104\n            rowConditions[i].length == colConditions[i].length == 2\n            1 <= abovei, belowi, lefti, righti <= k\n            abovei != belowi\n            lefti != righti\n        */\n        //topology sort.\n        vector<int> row = topo(k, rowConditions);\n        vector<int> col = topo(k, colConditions);\n\n        if(row.empty() || col.empty() )\n            return {};\n        vector<pair<int,int>> pos(k+1, {0,0}); //p[v]: (x,y)\n        for(int i=0; i<k; i++) {\n            pos[row[i]].first = i;\n        }\n        for(int j=0; j<k; j++) {\n            pos[col[j]].second = j;\n        }\n\n        vector<vector<int>> matrix(k, vector<int>(k,0));\n        for(int v=1; v<=k; v++) {\n            matrix[pos[v].first][pos[v].second] = v;\n        }\n\n        return matrix;\n\n    }\n\n    vector<int> topo(int k, vector<vector<int>>& conditions) {\n        vector<vector<int>> next(k+1,vector<int>()); //next[i]: adjancent nodes for ith node.\n        vector<int> inDegree(k+1,0); //ith node in degree.\n\n        for(auto& x: conditions) {\n            next[x[0]].push_back(x[1]);\n            inDegree[x[1]]++;\n        }\n\n        queue<int> q;\n        for(int v=1; v<=k; v++) {\n            if(inDegree[v] == 0) \n                q.push(v);\n        }\n\n        vector<int> res;\n        while(!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            res.push_back(cur);\n\n            for(int x:next[cur]) {\n                inDegree[x]--;\n                if(inDegree[x] == 0)\n                    q.push(x);\n            }\n        }\n\n        if(res.size()!=k) //check loop.\n            return {};\n        return res;\n\n    };\n};","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"build-a-matrix-with-conditions","has_notes":false,"flag_type":1}