{"id":1298221504,"question_id":3464,"lang":"cpp","lang_name":"C++","time":"7 months, 2 weeks","timestamp":1719186541,"status":10,"status_display":"Accepted","runtime":"97 ms","url":"/submissions/detail/1298221504/","is_pending":"Not Pending","title":"Maximize Total Cost of Alternating Subarrays","memory":"76 MB","code":"class Solution {\npublic:\n    /*\n    You are given an integer array nums with length n.\n\nThe cost of a subarray nums[l..r], where 0 <= l <= r < n, is defined as:\n\ncost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)r − l\n\nYour task is to split nums into subarrays such that the total cost of the subarrays is maximized, ensuring each element belongs to exactly one subarray.\n\nFormally, if nums is split into k subarrays, where k > 1, at indices i1, i2, ..., ik − 1, where 0 <= i1 < i2 < ... < ik - 1 < n - 1, then the total cost will be:\n\ncost(0, i1) + cost(i1 + 1, i2) + ... + cost(ik − 1 + 1, n − 1)\n\nReturn an integer denoting the maximum total cost of the subarrays after splitting the array optimally.\n\nNote: If nums is not split into subarrays, i.e. k = 1, the total cost is simply cost(0, n - 1).\n*/\n    long long maximumTotalCost(vector<int>& nums) { //-109 <= nums[i] <= 109; 1 <= nums.length <= 105\n        if(nums.size() == 1)\n            return nums[0];\n    \n/*\nsecondPrev holds the maximum cost for the subarray ending two indices before the current index.\nfirstPrev holds the maximum cost for the subarray ending at the previous index.\nInitially, secondPrev is set to the first element (nums[0]), as the subarray consisting of the first element only has that cost.\nfirstPrev is set to the maximum of two possible subarrays: [nums[0], nums[1]] or [nums[0], -nums[1]], which corresponds to nums[0] + nums[1] or nums[0] - nums[1].\nIterate Through the Array:\n\nFor each element starting from the third one (index 2), calculate the maximum cost considering extending the subarray from two indices back or extending the subarray from one index back.\nUpdate secondPrev and firstPrev for the next iteration.\nReturn Result:\n\nAfter processing all elements, firstPrev will contain the maximum total cost.\n*/\n\n        //initialize values for dp\n        long secondPrev = nums[0];\n        long firstPrev = max( nums[0]-nums[1], nums[0]+nums[1]); // 1 split or 2 splits.\n\n        for(int i=2; i<nums.size(); i++) {\n            //secondPrev+nums[i-1]-nums[i]: add to the secondPrev split, so in this case the previous num: nums[i-1] is also in that split.\n            long current = max(secondPrev+nums[i-1]-nums[i], firstPrev+nums[i]); //firstPrev+nums[i]: add a new split or directly add to the previous split. \n\n            secondPrev = firstPrev;\n            firstPrev = current;\n        }\n\n        return firstPrev;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximize-total-cost-of-alternating-subarrays","has_notes":false,"flag_type":1}