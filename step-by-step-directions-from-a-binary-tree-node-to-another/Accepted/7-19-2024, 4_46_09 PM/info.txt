{"id":1326741764,"question_id":2217,"lang":"cpp","lang_name":"C++","time":"6 months, 3 weeks","timestamp":1721432769,"status":10,"status_display":"Accepted","runtime":"138 ms","url":"/submissions/detail/1326741764/","is_pending":"Not Pending","title":"Step-By-Step Directions From a Binary Tree Node to Another","memory":"115.9 MB","code":"/*You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.\n\nFind the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:\n\n'L' means to go from a node to its left child node.\n'R' means to go from a node to its right child node.\n'U' means to go from a node to its parent node.\nReturn the step-by-step directions of the shortest path from node s to node t.*/\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string getDirections(TreeNode* root, int startValue, int destValue) {\n        /* The number of nodes in the tree is n.\n            2 <= n <= 105\n            1 <= Node.val <= n\n            All the values in the tree are unique.\n            1 <= startValue, destValue <= n\n            startValue != destValue\n        */\n\n        //path from root to start.     first we need to remove the common nodes.      finally reverse.\n        string root_start;\n        rootDirections(root, startValue, root_start);\n        reverse(root_start.begin(), root_start.end());\n        //cout << \"root_start = \"<< root_start << endl;\n\n        //path from root to end\n        string root_dest;\n        rootDirections(root, destValue, root_dest);\n        reverse(root_dest.begin(), root_dest.end());\n        //cout << \"root_dest = \"<< root_dest << endl;\n\n        int i=0;\n        while(i< root_start.length() && i < root_dest.length() ) {\n            if(root_start[i] == root_dest[i]) {\n                i++;\n            } else \n                break;\n        }\n\n        root_start.erase(0, i);\n        //cout << \"root_start = \"<< root_start << endl;\n        root_dest.erase(0, i);\n        //cout << \"root_dest = \"<< root_dest << endl;\n\n        //reverse root_start\n        for(int i=0; i<root_start.length(); i++) {\n            root_start[i] = 'U';\n        }\n\n        return root_start + root_dest;\n    }\n\n    bool rootDirections(TreeNode* root, int value, string &path) {\n        \n        if(root == nullptr) //this should never happen.\n            return false;\n        \n        if(root->val == value)\n            return true;\n        if( root->left && rootDirections(root->left, value, path) )\n            path.push_back('L');\n        else if ( root->right && rootDirections(root->right, value, path) )\n            path.push_back('R');\n\n        return !path.empty(); //this should never happen.\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"step-by-step-directions-from-a-binary-tree-node-to-another","has_notes":false,"flag_type":1}