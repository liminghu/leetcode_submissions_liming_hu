{"id":1397728468,"question_id":334,"lang":"cpp","lang_name":"C++","time":"4 months, 2 weeks","timestamp":1726945566,"status":10,"status_display":"Accepted","runtime":"86 ms","url":"/submissions/detail/1397728468/","is_pending":"Not Pending","title":"Increasing Triplet Subsequence","memory":"114.5 MB","code":"/*\nGiven an integer array nums, return true if there exists a triple of indices (i, j, k)\n such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.\n 1 <= nums.length <= 5 * 105\n-231 <= nums[i] <= 231 - 1\nFollow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity?\n*/\nclass Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        vector<int> q;\n        for(auto x:nums) {\n            if(q.empty() || x> q.back()) {\n                q.push_back(x);\n            } else {\n                auto iter = lower_bound(q.begin(), q.end(), x);\n                *iter = x;\n            }\n            if(q.size() == 3)\n                return true;\n        }\n        return false;\n\n/*        int sz = nums.size();\n        if( sz < 3 )\n            return false;\n        \n        vector<int> leftMin(sz,0);\n        vector<int> rightMax(sz,0);\n\n        leftMin[0] = INT_MAX;\n        for(int i=1; i<sz; i++)\n            leftMin[i] = min(leftMin[i-1], nums[i-1]);\n\n        rightMax[sz-1] = INT_MIN;\n        for(int i=sz-2; i>=0; i--)\n            rightMax[i] = max(rightMax[i+1], nums[i+1]);    \n\n        for(int j=0; j<sz; j++) { //i < j < k and nums[i] < nums[j] < nums[k]\n            if(leftMin[j] <nums[j] && nums[j] < rightMax[j])\n                return true;\n        }\n        return false;   */     \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"increasing-triplet-subsequence","has_notes":false,"flag_type":1}