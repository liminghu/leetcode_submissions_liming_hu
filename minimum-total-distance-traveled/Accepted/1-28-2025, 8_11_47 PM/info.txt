{"id":1523932411,"question_id":2554,"lang":"cpp","lang_name":"C++","time":"1 week, 2 days","timestamp":1738123907,"status":10,"status_display":"Accepted","runtime":"37 ms","url":"/submissions/detail/1523932411/","is_pending":"Not Pending","title":"Minimum Total Distance Traveled","memory":"20.5 MB","code":"using LL = long long;\nclass Solution {\n    //dp[i][j]表示前i个工厂覆盖了前j个机器人时，所需要的最小路径和\n    LL dp[101][101]; //1 <= robot.length, factory.length <= 100\n    LL dist[101][101][101]; //dist[i][j-k+1][k]表示最后k个机器人都送到第i个工厂时，所对应的总路程。\npublic:\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n        //factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.\n        int m = robot.size();\n        int n = factory.size();\n\n        sort(robot.begin(), robot.end());\n        sort(factory.begin(), factory.end());\n        for(int i=0; i<n; i++) { //for n factories\n            for(int j=0; j<m; j++) { //for m robots.\n                LL sum = 0;\n                for(int k=j; k<m; k++) {\n                    sum += abs(factory[i][0]-robot[k]);\n                    dist[i][j][k] = sum;  //dist[i][j-k+1][k]表示最后k个机器人都送到第i个工厂时，所对应的总路程。\n                }\n            }\n        }\n        //dp[0][j]\n        dp[0][0] = 0;\n        for(int j=1; j<=m; j++) {\n            if(j<=factory[0][1])\n                dp[0][j] = dist[0][0][j-1];\n            else \n                dp[0][j] = LLONG_MAX/2;\n        }\n       for(int i=1; i<n; i++) { //for n factories\n            for(int j=1; j<=m; j++) { //for m robots.       \n                dp[i][j] = dp[i-1][j]; //k=0\n                for(int k=0; k<=min(j, factory[i][1]); k++)\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-k]+dist[i][j-k][j-1]);\n            }\n       } \n       return dp[n-1][m];\n    }\n};","compare_result":"1111111111111111111111111111111111111111","title_slug":"minimum-total-distance-traveled","has_notes":false,"flag_type":1}