{"id":1230732730,"question_id":670,"lang":"cpp","lang_name":"C++","time":"10 months","timestamp":1712962278,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1230732730/","is_pending":"Not Pending","title":"Maximum Swap","memory":"7.1 MB","code":"/*思路：从右 to left，update maxIndex,同时找leftMost最小的数字去交换\n怎么想出这个算法的？\n1.\t观察规律\n\t17772\n77712\n1.\t选两个位置的数字交换，选一个高位的小数字，和一个低位的大数字，交换后，整体会变大\n2.\t要求一次交换最大？选最低位的大数字，和一个最高位的小数字交换\n 2. 大概形成思路思路：\n\t算法要从右到左，找低位的大数字，并且要找最大的数字\n找leftmost的高位数字，小于大数字，就交换\n1.\tPropose 算法和数据结构：\n\trightMax，从右到左更新\n3. Edge Case Coverage：\n\t不需要交换怎么办？没找到大数字和小数字交换\n\n*/\nclass Solution {\npublic:\n    int maximumSwap(int num) { //assume non negative int.   2736\n        string num_s = to_string(num); //number to string:    2 7  3 6 /n\n        int n = num_s.size();\n        int maxPos =  n - 1;\n        int bestSrc = -1, bestDest = -1;\n\n        for(int i=n-1; i>=0; i--) {\n            if(num_s[i]> num_s[maxPos])\n                maxPos = i;\n            else if (num_s[i] < num_s[maxPos]) {\n                bestSrc = maxPos;\n                bestDest = i;\n            }\n        }\n\n        if(bestSrc != -1 )\n            swap(num_s[bestSrc], num_s[bestDest]);\n\n        return stoi(num_s);\n\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-swap","has_notes":false,"flag_type":1}