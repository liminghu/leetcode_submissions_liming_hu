{"id":1404416911,"question_id":64,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1727482421,"status":10,"status_display":"Accepted","runtime":"13 ms","url":"/submissions/detail/1404416911/","is_pending":"Not Pending","title":"Minimum Path Sum","memory":"15 MB","code":"/*\nGiven a m x n grid filled with non-negative numbers, find a path from top left to \nbottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\n0 <= grid[i][j] <= 200\n*/\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int m= grid.size();\n        int n = grid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n,0));\n        dp[m-1][n-1] = grid[m-1][n-1];\n        for(int i=m-1; i>=0; i--) {\n            for(int j=n-1; j>=0; j--) {\n                if(i==m-1 && j==n-1)\n                    continue;\n                else if(i==m-1)\n                    dp[i][j] = dp[i][j+1]+grid[i][j];\n                else if(j==n-1) \n                    dp[i][j] = dp[i+1][j]+grid[i][j];\n                else\n                    dp[i][j] = grid[i][j] + min(dp[i][j+1], dp[i+1][j]);\n            }\n        }\n        return dp[0][0];\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-path-sum","has_notes":false,"flag_type":1}