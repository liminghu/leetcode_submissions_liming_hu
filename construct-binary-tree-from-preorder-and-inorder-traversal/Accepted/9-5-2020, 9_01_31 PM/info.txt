{"id":391664559,"question_id":105,"lang":"cpp","lang_name":"C++","time":"4 years, 5 months","timestamp":1599364891,"status":10,"status_display":"Accepted","runtime":"44 ms","url":"/submissions/detail/391664559/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"26.3 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n\t\treturn helper(0, 0, inorder.size()-1, preorder, inorder);\n    };\nprivate: \n\tTreeNode* helper(int preStart, int inStart, int inEnd, vector<int>& preorder, vector<int>& inorder) {\n\t\tif (preStart > preorder.size() - 1 || inStart > inEnd ) \n\t\t\treturn nullptr;\n\t\t\n\t\tTreeNode* root = new TreeNode( preorder[preStart] );\n\t\tint inIndex = 0; //index of current root in inorder;\n\t\tfor (int i = inStart; i <= inEnd; i++) {\n\t\t\tif (inorder[i] == root->val) {\n\t\t\t\tinIndex = i;\n\t\t\t}\n\t\t};\n\t\t\n\t\troot->left = helper( preStart+1, inStart, inIndex - 1, preorder, inorder);\n\t\troot->right = helper( preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder );\n\t\treturn root;\n\t}\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","has_notes":false,"flag_type":1}