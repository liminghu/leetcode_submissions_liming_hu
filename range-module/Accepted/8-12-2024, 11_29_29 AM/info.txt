{"id":1353498284,"question_id":715,"lang":"cpp","lang_name":"C++","time":"5 months, 4 weeks","timestamp":1723487369,"status":10,"status_display":"Accepted","runtime":"160 ms","url":"/submissions/detail/1353498284/","is_pending":"Not Pending","title":"Range Module","memory":"75.2 MB","code":"/*A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented \nas half-open intervals and query about them.\n\nA half-open interval [left, right) denotes all the real numbers x where left <= x < right.\n\nImplement the RangeModule class:\n\nRangeModule() Initializes the object of the data structure.\nvoid addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. \nAdding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval \n[left, right) that are not already tracked.\nboolean queryRange(int left, int right) Returns true if every real number in the interval [left, right) is currently \nbeing tracked, and false otherwise.\nvoid removeRange(int left, int right) Stops tracking every real number currently being tracked in the half-open \ninterval [left, right).\n*/\nclass RangeModule {\npublic:\n    map<int, int> mp;\n    RangeModule() {\n        \n    }\n    \n/*\n      A            B         C         D\nL____________   ______  __________R  _____\n   left_____________________right\n*/\n\n/*\nSo if there are range of values that are \"equal\" with respect to the comparison being used, \nlower_bound gives you the first of this, \nupper_bound gives you one-past-the-end of these. \nThis is the normal pattern of STL ranges [first, last).\nvalue a a a b b b c c c\nindex 0 1 2 3 4 5 6 7 8\nbound       l     u\n*/\n    void addRange(int left, int right) {\n        int leftBound = left;\n        auto iter1 = mp.lower_bound(left); //first greater than or equal to left.\n        if( iter1!=mp.begin() && prev(iter1)->second >=leftBound ) {\n            iter1 = prev(iter1);\n            leftBound = iter1->first;\n        }\n\n        auto iter2 = mp.upper_bound(right); //first greater than right. open.\n        int rightBound = right;\n        if( iter2!=mp.begin() && prev(iter2)->second >=rightBound ) {\n            rightBound = prev(iter2)->second;\n        }\n        mp.erase(iter1, iter2);  //Removes from the map container either a single element or a range of elements ([first,last)).\n        mp[leftBound] = rightBound;        \n    }\n /*\n      A            B         C         D\nL____________   ______  __________R  _____\n   left_____________________right\n*/\n\n    bool queryRange(int left, int right) {\n        auto iter = mp.upper_bound(left); //last greater than  left.\n\n        return iter!=mp.begin() && prev(iter)->second >= right;\n        \n    }\n /*\n      A            B         C         D\nL____________   ______  __________R  _____\n   left_____________________right\n*/   \n    void removeRange(int left, int right) {\n        auto iter1 = mp.lower_bound(left); //first greater than or equal to left.\n        int h1 = 0, t1 = 0;\n        if(iter1 !=mp.begin() && prev(iter1)->second > left) {\n            iter1 = prev(iter1);\n            h1 = iter1->first;\n            t1 = left;\n        }\n        auto iter2 = mp.upper_bound(right);\n        int h2 = 0, t2 = 0;\n        if(iter2 !=mp.begin() && prev(iter2)->second > right) {\n            h2 = right;\n            t2 = prev(iter2)->second;\n        }\n\n        mp.erase(iter1, iter2);\n        if(h1!=0) mp[h1] = t1;\n        if(h2!=0) mp[h2] = t2;\n    }\n};\n\n/**\n * Your RangeModule object will be instantiated and called as such:\n * RangeModule* obj = new RangeModule();\n * obj->addRange(left,right);\n * bool param_2 = obj->queryRange(left,right);\n * obj->removeRange(left,right);\n */","compare_result":"11111111111111111111111111111111111111111111111111111111","title_slug":"range-module","has_notes":false,"flag_type":1}