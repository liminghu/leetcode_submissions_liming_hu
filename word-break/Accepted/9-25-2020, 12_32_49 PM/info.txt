{"id":400673614,"question_id":139,"lang":"cpp","lang_name":"C++","time":"4 years, 4 months","timestamp":1601062369,"status":10,"status_display":"Accepted","runtime":"24 ms","url":"/submissions/detail/400673614/","is_pending":"Not Pending","title":"Word Break","memory":"14.7 MB","code":"class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n\t\t//create a hashset of words for fast query.\n\t\tunordered_set<string> dict(wordDict.cbegin(), wordDict.cend()); //cbegin: const iterator.\n\t\t\n\t\treturn wordBreak(s, dict);\n   }\n   \n   bool wordBreak(const string& s, const unordered_set<string>& dict) {\n\t\t//in memory, directly return.\n\t\tif(mem_.count(s)) return mem_[s];\n\t\tif(dict.count(s)) { //whole string is a word, memorize it and return.\n\t\t\tmem_[s] = true;\n\t\t\treturn mem_[s];\n\t\t};\n\t\t\n\t\t//try every break point.\n\t\tfor(int j=1; j < s.length(); j++) {\n\t\t\tconst string left = s.substr(0, j);\n\t\t\tconst string right = s.substr(j);\n\t\t\t//find the solution for s.\n\t\t\tif(dict.count(right) && wordBreak(left, dict) ) {\n\t\t\t\tmem_[s] = true;\n\t\t\t    return mem_[s];\n\t\t\t}\n\t\t};\n\t\t\n\t\t//no solution for s, memorize it and return.\n\t\tmem_[s] = false;\n\t\treturn false;\n   }\nprivate:\n\tunordered_map<string, bool> mem_;\n};","compare_result":"1111111111111111111111111111111111111111111","title_slug":"word-break","has_notes":false,"flag_type":1}