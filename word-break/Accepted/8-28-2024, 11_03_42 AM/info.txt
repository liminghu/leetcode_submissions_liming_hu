{"id":1371436732,"question_id":139,"lang":"cpp","lang_name":"C++","time":"5 months, 1 week","timestamp":1724868222,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1371436732/","is_pending":"Not Pending","title":"Word Break","memory":"12.2 MB","code":"class Solution {\n    class TrieNode {\n        public:\n            TrieNode* child[26];\n            bool isEnd;\n            TrieNode() {\n                for(int i=0; i<26; i++) \n                    child[i] = NULL;\n                isEnd = false;\n            }\n    };\n    TrieNode* root;\n    int memo[300];\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        root = new TrieNode();\n        for(auto word: wordDict) {\n            TrieNode* node = root;\n            for(auto ch: word) {\n                if(node->child[ch-'a'] == NULL) \n                   node->child[ch-'a'] = new TrieNode(); \n                node = node->child[ch-'a'];\n            }\n            node->isEnd = true;\n        }\n        return dfs(s, 0);\n\n    \n    /*    unordered_map<string, bool> dict;\n        for(int i=0; i<wordDict.size(); i++) {\n            dict[wordDict[i]] = true;\n        };\n\n        int sz = s.length();\n        vector<int> dp_wb_str_i(sz+1, 0); //until index i, the word can be break.\n        dp_wb_str_i[0] = 1; //init.\n        \n        for(int i=1; i<=sz; i++ ) {            //str until i, at least one char.\n            //break point: suppose after the break point, it is one word. \n            for(int b=0; b<i; b++) {\n                string sub = s.substr(b, i-b);\n                if( dict.find(sub) != dict.end() )  {//found\n                    dp_wb_str_i[i] = max(dp_wb_str_i[i], dp_wb_str_i[b]);  //bottom up. \n                }\n            }\n        }\n\n        return dp_wb_str_i[sz]==1; */\n        \n    }\n\n    bool dfs(string& s, int cur) {\n        if(cur == s.size())\n            return true;\n\n        if(memo[cur] == 1)\n            return false;\n\n        TrieNode* node = root;\n        for(int i=cur; i<s.size(); i++) {\n            if(node->child[ s[i]-'a' ]  != NULL) {\n                node = node->child[ s[i]-'a' ];\n                if(node->isEnd && dfs(s,i+1))\n                    return true;\n            } else\n                break;\n        }\n        memo[cur] = 1;\n        return false;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111","title_slug":"word-break","has_notes":false,"flag_type":1}