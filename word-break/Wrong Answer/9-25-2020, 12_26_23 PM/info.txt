{"id":400671605,"question_id":139,"lang":"cpp","lang_name":"C++","time":"4 years, 4 months","timestamp":1601061983,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/400671605/","is_pending":"Not Pending","title":"Word Break","memory":"N/A","code":"//DP: 记忆化递归。\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n\t\t//create a hashset of words for fast query.\n\t\tunordered_set<string> dict(wordDict.cbegin(), wordDict.cend()); //cbegin: const iterator.\n\t\t\n\t\treturn wordBreak(s, dict);\n   }\n   \n   bool wordBreak(const string& s, const unordered_set<string>& dict) {\n\t\t//in memory, directly return.\n\t\tif(mem_.count(s)) return mem_[s];\n\t\tif(dict.count(s)) { //whole string is a word, memorize it and return.\n\t\t\tmem_[s] = true;\n\t\t\treturn true;\n\t\t};\n\t\t\n\t\t//try every break point.\n\t\tfor(int j=1; j < s.length(); j++) {\n\t\t\tconst string left = s.substr(0, j);\n\t\t\tconst string right = s.substr(j);\n\t\t\t//find the solution for s.\n\t\t\tif(dict.count(right) && wordBreak(left, dict) )\n\t\t\t\tmem_[s] = true;\n\t\t\t    return true;\n\t\t};\n\t\t\n\t\t//no solution for s, memorize it and return.\n\t\tmem_[s] = false;\n\t\treturn false;\n   }\nprivate:\n\tunordered_map<string, bool> mem_;\n};","compare_result":"1101111111101111001001011101111111110100000","title_slug":"word-break","has_notes":false,"flag_type":1}