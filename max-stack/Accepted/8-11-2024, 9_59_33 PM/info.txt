{"id":1352744967,"question_id":716,"lang":"cpp","lang_name":"C++","time":"5 months, 4 weeks","timestamp":1723438773,"status":10,"status_display":"Accepted","runtime":"257 ms","url":"/submissions/detail/1352744967/","is_pending":"Not Pending","title":"Max Stack","memory":"137.5 MB","code":"/*\nDesign a max stack data structure that supports the stack operations and supports finding \nthe stack's maximum element.\n\nImplement the MaxStack class:\n\nMaxStack() Initializes the stack object.\nvoid push(int x) Pushes element x onto the stack.\nint pop() Removes the element on top of the stack and returns it.\nint top() Gets the element on the top of the stack without removing it.\nint peekMax() Retrieves the maximum element in the stack without removing it.\nint popMax() Retrieves the maximum element in the stack and removes it. If there is more than \none maximum element, only remove the top-most one.\nYou must come up with a solution that supports O(1) for each top call and O(logn) for each other call.\n*/\nclass MaxStack {\nprivate:\n    priority_queue<pair<int, int>> pq_max; //max priority queue.\n    stack<pair<int,int>> st;\n    unordered_set<int> removed;\n    int cnt;\npublic:\n    MaxStack() {\n        /*  -107 <= x <= 107\n            At most 105 calls will be made to push, pop, top, peekMax, and popMax.\n            There will be at least one element in the stack when pop, top, peekMax, or popMax is called.\n        */\n        cnt = 0; //id\n    }\n    \n    void push(int x) {\n        pq_max.push({x,cnt});\n        st.push({x,cnt});\n        cnt++;\n    }\n    \n    int pop() {\n        /*we first check the ID of its top element, if is \n        turns out to be an ID in removed, that is, it was removed previously, \n        we need to remove the current top element until its ID is not in \n        removed to make sure the top still exists*/\n        while(removed.count(st.top().second)) { //check id.\n            st.pop();\n        }\n        const pair<int,int> p = st.top();\n        st.pop();\n        removed.insert(p.second);\n        return p.first;\n    }\n    \n    int top() {\n        while(removed.count(st.top().second)) {\n            st.pop();\n        }\n        return st.top().first;     \n    }\n    \n    int peekMax() {\n        while(removed.count(pq_max.top().second)) {\n            pq_max.pop();\n        }\n        return pq_max.top().first;\n        \n    }\n    \n    int popMax() {\n        while(removed.count(pq_max.top().second)) {\n            pq_max.pop();\n        }\n        const pair<int,int> p = pq_max.top();\n        pq_max.pop();\n        removed.insert(p.second);\n        return p.first;\n    }\n};\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack* obj = new MaxStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->peekMax();\n * int param_5 = obj->popMax();\n */","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"max-stack","has_notes":false,"flag_type":1}