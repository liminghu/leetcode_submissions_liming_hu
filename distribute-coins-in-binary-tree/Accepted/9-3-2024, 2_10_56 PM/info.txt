{"id":1378178223,"question_id":1021,"lang":"cpp","lang_name":"C++","time":"5Â months","timestamp":1725397856,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1378178223/","is_pending":"Not Pending","title":"Distribute Coins in Binary Tree","memory":"17 MB","code":"/*\nYou are given the root of a binary tree with n nodes where each node in the tree has node.val coins. \nThere are n coins in total throughout the whole tree.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may \nbe from parent to child, or from child to parent.\nReturn the minimum number of moves required to make every node have exactly one coin.\n*/\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int distributeCoins(TreeNode* root) {\n        /*  The number of nodes in the tree is n.\n            1 <= n <= 100\n            0 <= Node.val <= n\n            The sum of all Node.val is n.\n        */\n        if(root == NULL)\n            return 0;\n        int res = 0;\n        int leftNode = 0;\n        int leftCoins = numCoins(root->left, leftNode);\n        //cout << \"leftCoins = \" << leftCoins << \" leftNode = \" << leftNode << endl;\n        int numLeftDistributions = abs(leftNode - leftCoins);\n        int totalLeft = numLeftDistributions;\n        if(root->left != NULL) {\n            if(root->left->val > 1) \n                root->left->val -= abs(leftCoins -leftNode);\n            else\n                root->left->val += abs(leftCoins -leftNode);\n            totalLeft += distributeCoins(root->left);\n            root->val = 1;\n        };\n        res += totalLeft;\n\n        int rightNode = 0;\n        int rightCoins = numCoins(root->right, rightNode);\n        //cout << \"rightCoins = \" << rightCoins << \" rightNode = \" << rightNode << endl;\n        int numRightDistributions = abs(rightNode - rightCoins);\n        int totalright = numRightDistributions;\n        if(root->right != NULL) {\n            if(root->right->val > 1)\n                root->right->val -= abs(rightCoins -rightNode);\n            else\n                root->right->val += abs(rightCoins -rightNode);\n            totalright += distributeCoins(root->right);\n            root->val = 1;\n        };\n        res += totalright;\n\n        return res;\n    }\n\n    int numCoins(TreeNode* root, int& numNode) {\n        if(root==NULL) {\n            numNode = 0;\n            return 0;\n        }\n        int leftNode = 0;\n        int leftCoins = numCoins(root->left, leftNode);\n        int rightNode = 0;\n        int rightCoins =  numCoins(root->right, rightNode);\n        numNode = 1 + leftNode + rightNode;\n        return root->val + leftCoins + rightCoins;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"distribute-coins-in-binary-tree","has_notes":false,"flag_type":1}