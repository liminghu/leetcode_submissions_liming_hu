{"id":1314682599,"question_id":10,"lang":"cpp","lang_name":"C++","time":"7 months","timestamp":1720499357,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1314682599/","is_pending":"Not Pending","title":"Regular Expression Matching","memory":"20.8 MB","code":"/*\nGiven an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.​​​​\n'*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n*/\nclass Solution {\nprivate:\n    vector<vector<int>> dp; \npublic:\n    bool isMatch(string s, string p) {\n        /*\n        1 <= s.length <= 20\n        1 <= p.length <= 20\n        s contains only lowercase English letters.\n        p contains only lowercase English letters, '.', and '*'.\n        It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\n        */\n\n        //dp\n        // does text[i:] and pattern[j:] match?\n        dp = vector(s.length()+1, vector<int>(p.length()+1, -1)); //0: no-match, 1: match, -1: do not know \n        bool result = false;\n        result = solve(s, p, 0, 0); //0: start of s, 0: start of p. \n        return result;\n    }\n    bool solve(string s, string p, int end_s, int end_p) {\n        bool result = false;\n\n        if(dp[end_s][end_p] != -1)\n            return dp[end_s][end_p] == 1;\n        \n        if(end_p == p.length()) //to the end of pattern.\n            return end_s == s.length(); //is the string at the end?\n        else {\n             bool first_match = (end_s < s.length() && (p[end_p] == s[end_s] || p[end_p] == '.'));\n\n             if (end_p + 1 < p.length() && p[end_p + 1] == '*') {\n                result = ( solve(s, p, end_s, end_p + 2) //match zero of the preceding element.\n                || (first_match && solve( s, p, end_s + 1, end_p )) ); //Matches more of the preceding element.\n            } else { //no *\n                result = first_match && solve(s, p, end_s + 1, end_p + 1);\n            }\n        }\n\n        dp[end_s][end_p] = result;\n\n        return result;\n\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"regular-expression-matching","has_notes":false,"flag_type":1}