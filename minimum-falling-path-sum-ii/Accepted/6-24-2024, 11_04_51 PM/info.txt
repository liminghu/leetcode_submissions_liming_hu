{"id":1299486837,"question_id":1224,"lang":"cpp","lang_name":"C++","time":"7 months, 2 weeks","timestamp":1719295491,"status":10,"status_display":"Accepted","runtime":"127 ms","url":"/submissions/detail/1299486837/","is_pending":"Not Pending","title":"Minimum Falling Path Sum II","memory":"18.4 MB","code":"class Solution {\npublic:\n/*\nGiven an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.\nA falling path with non-zero shifts is a choice of exactly one element from each row of grid such \nthat no two elements chosen in adjacent rows are in the same column.\n*/\n    int minFallingPathSum(vector<vector<int>>& grid) { //n == grid.length == grid[i].length\n                                                        //1 <= n <= 200\n                                                        //-99 <= grid[i][j] <= 99\n        int sz = grid.size();\n        vector<vector<int>> dp(sz, vector<int>(sz, 0));\n        dp[0] = grid[0];\n\n        for(int i=1; i<sz; i++) {\n            for(int j=0; j<sz; j++) {\n                //dp[i][j] = min(dp[i-1][0..sz]), exclude j   + grid[i][j];\n                int minPre = INT_MAX;\n                for(int k=0; k<sz; k++) {\n                    if(k!=j) {\n                        minPre = min(minPre, dp[i-1][k]);\n                    };\n                }\n                dp[i][j] = minPre + grid[i][j];\n            }\n        };\n\n        int ret = INT_MAX;\n        for(int k=0; k<sz; k++) {\n            ret = min(ret, dp[sz-1][k]);       \n        } \n\n        return ret;\n        \n    }\n};","compare_result":"11111111111111111","title_slug":"minimum-falling-path-sum-ii","has_notes":false,"flag_type":1}