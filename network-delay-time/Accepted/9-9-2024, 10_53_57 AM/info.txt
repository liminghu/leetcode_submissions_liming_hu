{"id":1384551285,"question_id":744,"lang":"cpp","lang_name":"C++","time":"5Â months","timestamp":1725904437,"status":10,"status_display":"Accepted","runtime":"103 ms","url":"/submissions/detail/1384551285/","is_pending":"Not Pending","title":"Network Delay Time","memory":"56.7 MB","code":"/*You are given a network of n nodes, labeled from 1 to n. You are also given times, \na list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the \nsource node, vi is the target node, and wi is the time it takes for a signal to \ntravel from source to target.\n\nWe will send a signal from a given node k. Return the minimum time it takes for \nall the n nodes to receive the signal. If it is impossible for all the n nodes \nto receive the signal, return -1.\n1 <= k <= n <= 100\n1 <= times.length <= 6000\ntimes[i].length == 3\n1 <= ui, vi <= n\nui != vi\n0 <= wi <= 100\nAll the pairs (ui, vi) are unique. (i.e., no multiple edges.)\n*/\nclass Solution {\npublic:\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        //times[i] = (ui, vi, wi)\n /*       vector<vector<int>> adj[n+1];\n        for(auto& time: times) {\n            int source = time[0];\n            int dest = time[1];\n            int travelTime = time[2];\n            adj[ source ].push_back( {travelTime, dest}); //travletime, dest.\n        };       \n        vector<int> signalReceivedAt(n+1, INT_MAX);\n        queue<int> q;\n        q.push(k);\n        signalReceivedAt[k] = 0;\n        while(!q.empty()) {\n            int curNodeNum = q.front();\n            q.pop();\n            for(vector<int> edge: adj[curNodeNum]) {\n                int time = edge[0];\n                int neighborNode = edge[1];\n                int arrivalTime = signalReceivedAt[curNodeNum] + time;\n                if(signalReceivedAt[neighborNode] > arrivalTime ) {\n                    signalReceivedAt[neighborNode] = arrivalTime;\n                    q.push(neighborNode);\n                }\n            }\n        }        \n\n        int ret = INT_MIN;\n        for(int i=1; i<=n; i++) \n            ret = max(ret, signalReceivedAt[i]);\n        return ret == INT_MAX? -1: ret;*/\n\n        vector<vector<int>> adj[n+1];\n        for(auto& time: times) {\n            int source = time[0];\n            int dest = time[1];\n            int travelTime = time[2];\n            adj[ source ].push_back( {travelTime, dest}); //travletime, dest.\n        };\n        \n        vector<int> signalReceivedAt(n+1, INT_MAX);\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq; //minimum\n        pq.push({0, k}); //timeRecived, source.\n        signalReceivedAt[k] = 0;\n        while(!pq.empty()) {\n            vector<int> curNode = pq.top();\n            int curNodeTime = curNode[0];\n            int curNodeNum = curNode[1];\n            pq.pop();\n\n            if(curNodeTime > signalReceivedAt[curNodeNum] ) //This node will not help.\n                continue;\n            for(vector<int> edge: adj[curNodeNum]) {\n                int time = edge[0];\n                int neighborNode = edge[1];\n                if(signalReceivedAt[neighborNode] > curNodeTime + time ) {\n                    signalReceivedAt[neighborNode] = curNodeTime + time;\n                    pq.push({curNodeTime + time, neighborNode});\n                }\n            }\n        }\n\n        int ret = INT_MIN;\n        for(int i=1; i<=n; i++) \n            ret = max(ret, signalReceivedAt[i]);\n        return ret == INT_MAX? -1: ret;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"network-delay-time","has_notes":false,"flag_type":1}