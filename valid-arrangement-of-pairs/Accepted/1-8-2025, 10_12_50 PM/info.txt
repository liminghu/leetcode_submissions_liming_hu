{"id":1502633681,"question_id":2201,"lang":"cpp","lang_name":"C++","time":"4 weeks, 1 day","timestamp":1736403170,"status":10,"status_display":"Accepted","runtime":"422 ms","url":"/submissions/detail/1502633681/","is_pending":"Not Pending","title":"Valid Arrangement of Pairs","memory":"346.2 MB","code":"class Solution {\n    unordered_map<int, int> inDegree;\n    unordered_map<int, int> outDegree;\n    unordered_map<int, vector<int>> adj;\npublic:\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\n        //pairs[i] = [starti, endi].\n        for(auto& pair: pairs) {\n            int a = pair[0], b = pair[1];\n            inDegree[b]++;\n            outDegree[a]++;\n            adj[a].push_back(b);\n        }\n        int start = -1;\n        for(auto x: adj) {\n            int p = x.first;\n            if(outDegree[p]-inDegree[p] == 1)\n                start = p;\n        }\n        if(start==-1)\n            start = pairs[0][0];\n        vector<int> path; // p0, p1, p2...\n        dfs(start, path);\n        reverse(path.begin(), path.end());\n        vector<vector<int>> rets;\n        for(int i=0; i<path.size()-1; i++) {\n            rets.push_back({path[i], path[i+1]});\n        }\n        return rets;\n    }\n    void dfs(int start, vector<int>& path) {\n        while(adj[start].size()>0) {\n            int next = adj[start].back();\n            adj[start].pop_back();\n            dfs(next, path);\n        }\n        path.push_back(start);\n    }\n};","compare_result":"1111111111111111111111111111111111111111","title_slug":"valid-arrangement-of-pairs","has_notes":false,"flag_type":1}