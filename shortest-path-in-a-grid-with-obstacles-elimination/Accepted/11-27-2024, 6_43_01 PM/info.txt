{"id":1464674340,"question_id":1414,"lang":"cpp","lang_name":"C++","time":"2 months, 1 week","timestamp":1732761781,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1464674340/","is_pending":"Not Pending","title":"Shortest Path in a Grid with Obstacles Elimination","memory":"14 MB","code":"class Solution {\npublic:\n    int shortestPath(vector<vector<int>>& grid, int k) {\n        int m = grid.size();\n        int n = grid[0].size();\n        //(0, 0)   (m-1, n-1);\n        vector<pair<int,int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0,1}}; //up, down, left, or right\n        vector<vector<int>> objs(m, vector<int>(n, INT_MAX)); //seen[x][y]: min obstacles to reach (x, y)\n        queue<tuple<int,int,int>> q; //(x, y, obj)\n        int steps = 0;\n        q.push({0,0,0});\n        objs[0][0] = 0;\n        while( !q.empty() ) {\n            int sz = q.size();\n            while(sz--) {\n                int cur_x, cur_y, cur_obj;\n                tie(cur_x,cur_y,cur_obj) = q.front(); //tie is a function that creates a tuple of lvalue references\n                q.pop();\n                if(cur_x==m-1 && cur_y == n-1)\n                    return steps;\n                for(auto dir:dirs) {\n                    int x = cur_x + dir.first;\n                    int y = cur_y + dir.second;\n                    if(x<0 || x>=m || y<0 || y>=n)\n                        continue;\n                    int obj = cur_obj + grid[x][y]; //grid[x][y] =0, 1\n                    if( obj >= objs[x][y] || obj > k)\n                        continue;\n                    objs[x][y] = obj;\n                    q.push({x,y, obj});\n                }\n            }\n            steps++;\n        }\n        return -1;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-in-a-grid-with-obstacles-elimination","has_notes":false,"flag_type":1}