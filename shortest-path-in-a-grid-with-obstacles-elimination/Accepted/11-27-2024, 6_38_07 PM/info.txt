{"id":1464672332,"question_id":1414,"lang":"cpp","lang_name":"C++","time":"2 months, 1 week","timestamp":1732761487,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1464672332/","is_pending":"Not Pending","title":"Shortest Path in a Grid with Obstacles Elimination","memory":"13.8 MB","code":"class Solution {\npublic:\n    int shortestPath(vector<vector<int>>& grid, int k) {\n        int m = grid.size();\n        int n = grid[0].size();\n        //(0, 0)   (m-1, n-1);\n        vector<pair<int,int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0,1}}; //up, down, left, or right\n        vector<vector<int>> seen(m, vector<int>(n, INT_MAX)); //seen[x][y]: min obstacles to reach (x, y)\n        queue<tuple<int,int,int>> q; //(x, y, o)\n        int steps = 0;\n        q.push({0,0,0});\n        seen[0][0] = 0;\n        while(!q.empty()) {\n            int sz = q.size();\n            while(sz--) {\n                int cx, cy, co;\n                tie(cx,cy,co) = q.front();\n                q.pop();\n                if(cx==m-1 && cy == n-1)\n                    return steps;\n                for(auto dir:dirs) {\n                    int x = cx + dir.first;\n                    int y = cy + dir.second;\n                    if(x<0 || x>=m || y<0 || y>=n)\n                        continue;\n                    int obj = co + grid[x][y];\n                    if( obj >= seen[x][y] || obj > k)\n                        continue;\n                    seen[x][y] = obj;\n                    q.push({x,y, obj});\n                }\n            }\n            steps++;\n        }\n        return -1;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-in-a-grid-with-obstacles-elimination","has_notes":false,"flag_type":1}