{"id":1318996945,"question_id":1818,"lang":"cpp","lang_name":"C++","time":"6 months, 4 weeks","timestamp":1720809809,"status":10,"status_display":"Accepted","runtime":"106 ms","url":"/submissions/detail/1318996945/","is_pending":"Not Pending","title":"Maximum Score From Removing Substrings","memory":"27.3 MB","code":"/*You are given a string s and two integers x and y. You can perform two types of operations any number of times.\nRemove substring \"ab\" and gain x points.\nFor example, when removing \"ab\" from \"cabxbae\" it becomes \"cxbae\".\nRemove substring \"ba\" and gain y points.\nFor example, when removing \"ba\" from \"cabxbae\" it becomes \"cabxe\".\nReturn the maximum points you can gain after applying the above operations on s.\n*/\nclass Solution {\npublic:\n    //unordered_map<string, int> gain;\n    int maximumGain(string s, int x, int y) { //1 <= s.length <= 105; 1 <= x, y <= 104; s consists of lowercase English letters.\n       int sz = s.length();\n       if( sz <= 1 )\n            return 0;\n        if(sz == 2) {\n            if( s == \"ab\")\n                return x;\n            else if( s == \"ba\" )\n                return y;\n            else\n                return 0;  \n        } \n        stack<char> st;\n\n        int points = 0;  \n        int top = 0;\n        int bottom = 0;\n        char first = 'a';\n        char second = 'b';\n        if( x >= y) { //remove ab first. after remove all ab, there is no chance we will have ab any more.\n            top = x;\n            bottom = y;\n            first = 'a';\n            second = 'b';\n        } else {\n            top = y;\n            bottom = x;\n            first = 'b';\n            second = 'a';           \n        };\n        for(int i=0; i<sz; i++) {\n            if( !st.empty() && st.top() == first && s[i] == second) {\n                st.pop();\n                points += top; \n            } else \n                st.push(s[i]);\n        }\n\n        string new_s = \"\";\n        while( !st.empty() ) {\n            new_s.push_back(st.top());\n            st.pop();\n        }\n\n        reverse(new_s.begin(), new_s.end());\n        for(int i=0; i<new_s.length(); i++) {\n            if( !st.empty() && st.top() == second && new_s[i] == first ) {\n                st.pop();\n                points += bottom; \n            } else\n                st.push(new_s[i]);\n        }\n\n        return points;\n\n\n/*        if( s.length() <= 1 )\n            return 0;\n        if(s.length()==2) {\n            if( s==\"ab\")\n                return x;\n            else if(s==\"ba\")\n                return y;\n            else\n                return 0;   \n        }\n\n        int sz = s.length();\n        int maxGain = 0;\n        if( gain.find(s) != gain.end() )\n            return gain[s];\n\n        for(int i=0; i<sz-1; i++) {\n            if(s[i] == 'a' && s[i+1] == 'b') {\n                string s1 = s.substr( 0, i );\n                string s2 = s.substr( i+2, sz-i-2 );\n                maxGain = max( maxGain, x + maximumGain( s1 + s2, x, y));\n            } else if(s[i] == 'b' && s[i+1] == 'a') {\n                string s1 = s.substr( 0, i );\n                string s2 = s.substr( i+2, sz-i-2 );\n                maxGain =max( maxGain, y + maximumGain( s1 + s2, x, y));\n            } else if( s[i] != 'a' && s[i] != 'b') {\n                string s1 = s.substr(0, i);\n                int max1 = maximumGain(s1, x, y);\n                string s2 = s.substr(i+1, sz-i-1);\n                int max2 = maximumGain(s2, x, y);\n                maxGain = max( maxGain, max1 + max2 );\n            } else\n                continue;\n        }\n        gain[s] = maxGain;\n        return maxGain;  */  \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-score-from-removing-substrings","has_notes":false,"flag_type":1}