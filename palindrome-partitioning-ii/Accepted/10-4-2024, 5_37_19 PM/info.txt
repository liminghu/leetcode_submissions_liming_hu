{"id":1412080421,"question_id":132,"lang":"cpp","lang_name":"C++","time":"4Â months","timestamp":1728088639,"status":10,"status_display":"Accepted","runtime":"55 ms","url":"/submissions/detail/1412080421/","is_pending":"Not Pending","title":"Palindrome Partitioning II","memory":"61.3 MB","code":"/*\nGiven a string s, partition s such that every \nsubstring of the partition is a palindrome.\nReturn the minimum cuts needed for a palindrome partitioning of s.\nExample 1:\nInput: s = \"aab\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n\nExample 2:\nInput: s = \"a\"\nOutput: 0\n\nExample 3:\nInput: s = \"ab\"\nOutput: 1\n \n\nConstraints:\n1 <= s.length <= 2000\ns consists of lowercase English letters only.\n*/\nclass Solution {\npublic:\n    int minCut(string s) {\n        int n = s.length();\n        vector<vector<int>> palindrome(n, vector<int>(n, 1)); \n        //dp[i]: min cuts of s[0...i].\n        vector<int> dp(n, n); // n is the max.\n        \n        for(int l = 2; l<=n; l++) { //l: length.\n            for(int i=0, j=i+l-1; j<n; i++, j++) {\n                palindrome[i][j] = ( s[i]==s[j] ) && palindrome[i+1][j-1]; // i+1 > j-1 palindrome[i+1][j-1] = 1.\n            };\n        }; \n\n        for(int i=0; i<n; i++) {\n            if(palindrome[0][i]) {\n                dp[i] = 0;\n                continue;\n            };\n            //not a palindrome\n            for(int j=0; j<i; j++) {\n                if(palindrome[j+1][i])\n                    dp[i] = min(dp[i], dp[j]+1);\n            };\n        };\n        return dp[n-1];\n    }\n};\n\n\n//TLE\n/*class Solution {\npublic:\n    unordered_map<string,int> mp;\n        unordered_map<string,bool> palindrome;\n    int minCut(string s) {\n        if(mp.find(s)!= mp.end())\n            return mp[s];\n        if(isPalindrome(s)) {\n            mp[s] = 0;\n            return 0;\n        }\n        int size = s.size();        \n        if(size == 2) {\n            if(s[0] != s[1]) {\n                mp[s] = 1;\n                return 1;\n            }else { \n                return 0;\n                mp[s] = 0;\n            };\n        } \n\n        int res = INT_MAX;\n        for(int i=0; i<size-1; i++) {\n            string first = s.substr(0, i+1);\n            string second = s.substr(i+1, size-i-1);\n            int min_first = minCut(first);\n            mp[first] = min_first;\n            int min_second = minCut(second);\n            mp[second] = min_second;\n            //cout << \"i: \" << i << \" first: \" << min_first << \" second: \" << min_second << endl;\n            res = min(res, min_first+min_second);\n            //cout << \"res: \" << res << endl;\n        };\n        mp[s] = res+1;\n        return res+1;\n    }\n    bool isPalindrome( string s) {\n        if(palindrome.find(s)!=palindrome.end())\n            return palindrome[s];\n        int size = s.size();\n        if(size<=1) {\n            palindrome[s] = true;\n            return true;\n        }\n        int start = 0;\n        int end = size-1;\n        while(start<end) {\n            if(s[start] == s[end]) {\n                start++;\n                end--;\n            } else {\n                palindrome[s] = false;\n                return false;\n            }\n        };\n        palindrome[s] = true;\n        return true;\n    }\n};*/","compare_result":"1111111111111111111111111111111111111","title_slug":"palindrome-partitioning-ii","has_notes":false,"flag_type":1}