{"id":1369542868,"question_id":1285,"lang":"cpp","lang_name":"C++","time":"5 months, 2 weeks","timestamp":1724722552,"status":10,"status_display":"Accepted","runtime":"105 ms","url":"/submissions/detail/1369542868/","is_pending":"Not Pending","title":"Balance a Binary Search Tree","memory":"64 MB","code":"/*Given the root of a binary search tree, return a balanced binary search tree with the same node values.\n If there is more than one answer, return any of them.\nA binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1\n*/\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* balanceBST(TreeNode* root) {\n        if(root == nullptr)\n            return root;\n        vector<int> inorder;\n        inorderTraversal(root, inorder);\n        int n = inorder.size();\n        return buildBalancedBST(inorder, 0, n-1);\n\n    }\n\n    void inorderTraversal(TreeNode* root, vector<int>& inorder) {\n        if(root == nullptr)\n            return;\n        inorderTraversal(root->left, inorder);\n        inorder.push_back(root->val);\n        inorderTraversal(root->right, inorder);\n    }\n\n    TreeNode* buildBalancedBST(const vector<int>& inorder, int start, int end) {\n        if(start>end) \n            return nullptr;\n        \n        int mid = start+(end-start)/2;\n        TreeNode* left = buildBalancedBST(inorder, start, mid-1);\n        TreeNode* right = buildBalancedBST(inorder, mid+1, end); \n        return new TreeNode(inorder[mid], left, right);        \n    }\n};","compare_result":"11111111111111111","title_slug":"balance-a-binary-search-tree","has_notes":false,"flag_type":1}