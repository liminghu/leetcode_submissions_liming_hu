{"id":1401212432,"question_id":1576,"lang":"cpp","lang_name":"C++","time":"4 months, 2 weeks","timestamp":1727212562,"status":10,"status_display":"Accepted","runtime":"266 ms","url":"/submissions/detail/1401212432/","is_pending":"Not Pending","title":"Reorder Routes to Make All Paths Lead to the City Zero","memory":"120.4 MB","code":"/*\nThere are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two \ndifferent cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in \none direction because they are too narrow.\nRoads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.\nThis year, there will be a big event in the capital (city 0), and many people want to travel to this city.\nYour task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number \nof edges changed.\nIt's guaranteed that each city can reach city 0 after reorder.\n2 <= n <= 5 * 104\nconnections.length == n - 1\nconnections[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\n */\nclass Solution {\npublic:\n    int minReorder(int n, vector<vector<int>>& connections) {\n        vector<int> visited(n, 0); // n cities.\n        vector<vector<int>> adj(n);\n        vector<vector<int>> back(n);\n        int ans = 0;\n        for(auto c: connections) {\n            adj[ c[0] ].push_back(c[1]); // there is a road from c[0] to c[1].\n            back[ c[1] ].push_back( c[0] );  //there is a city c[0] back to c[1].\n        }\n        queue<int> q;\n        q.push(0);\n        while(!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            visited[cur] = 1;\n\n            //change dir for all arrows facing out.\n            for(auto a: adj[cur] ) { //from the city cur to ...\n                if(!visited[a]) {\n                    ans++;    //we need to reverse them: Starting from the city, we switch edges that are facing away from us.\n                    q.push(a);\n                }\n            }\n            \n            /*\n                If there is a node that faces inward to us that we haven't visited yet, it would be in our back vector.\n                We need to add inward facing nodes to the queue as well, since they might have neighbors that need to be flipped.\n            */\n            for(auto b: back[cur]) { //the cities back to cur\n                if(!visited[b])\n                    q.push(b);\n            }\n        }\n        return ans;\n\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reorder-routes-to-make-all-paths-lead-to-the-city-zero","has_notes":false,"flag_type":1}